# Kafein Staj - learning java

| G√ºn  | Konu |
| ------------- | ------------- |
| 1  | IDE se√ßimi ve Java‚Äôya ba≈ülangƒ±√ß  |
| 2  | Java‚Äôda deƒüi≈ükenler, temel veri tipleri, temel operat√∂rler ve control statements  |
| 3  | Java‚Äôda d√∂ng√ºler, diziler (arrays), string‚Äôler, paketler (packages), kullanƒ±cƒ±dan veri (input) alma  |
| 4  | Java‚Äôda metotlar (fonksiyonlar), class‚Äôlar (sƒ±nƒ±flar) ve kullanƒ±mlarƒ±  |
| 5  | Yazƒ±lƒ±m prensipleri ve OOP konseptine giri≈ü  |
| 6  | Java‚Äôda OOP - encapsulation (kaps√ºlleme), constructors (yapƒ±cƒ± bloklar) ve Access Modifiers  |
| 7  | Java‚Äôda OOP ‚Äì Inheritance (kalƒ±tƒ±m) ve metot overloading (a≈üƒ±rƒ± y√ºklenme)  |
| 8  | Java‚Äôda OOP ‚Äì Polymorphism (√ßok bi√ßimlilik), method overriding (metot ezme/ge√ßersiz kƒ±lma), Abstraction ve Abstract Class‚Äôlar (soyut sƒ±nƒ±f)  |
| 9  | Java‚Äôda OOP ‚Äì Interface (aray√ºzler), Inner Class ve Static terimi  |
| 10 | Java‚Äôda Collections (Koleksiyonlar) ‚Äì ArrayList ve Hashmap ve Java‚Äôda Exception Handling  |
| 11 | Java‚Äôda Generics ve Threading  |
| 12 | MySQL kurulumu, temel SQL sorgularƒ± ve Java‚Äôda JDBC ile database (veri tabanƒ±) baƒülantƒ±sƒ±  |
| 13 | Java‚Äôda JDBC ile veri tabanƒ± i≈ülemleri (SELECT, INSERT, UPDATE, DELETE) ve verileri nesnelere aktarma   |
| 14 | Java‚Äôda dosyalar ile √ßalƒ±≈ümak  |
| 15 | ƒ∞leri Seviye Java - Spring Framework‚Äôe giri≈ü  |
| 16 | ƒ∞leri Seviye Java - Hibernate  |
| 17 | ƒ∞leri seviye Java - Maven  |
| 18 | ƒ∞leri Seviye Java - Spring Boot  |
| 19 | Katmanlƒ± mimariler, application.properties dosyasƒ±, JPA ve √∂rnek bir proje  |
| 20 | Staj projesi ‚Äì MySQL‚Äôde proje i√ßin veri tabanƒ± olu≈üturma, Java‚Äôda veri tabanƒ± nesnesi i√ßin sƒ±nƒ±f olu≈üturma  |
| 21 | Staj projesi ‚Äì Projenin Data Access katmanƒ±nƒ±n yazƒ±lmasƒ±, application.properties dosyasƒ±nƒ±n konfig√ºrasyonu  |
| 22 | Staj Projesi ‚Äì Projenin Service katmanƒ± ve REST Api‚Äôƒ±nƒ±n yazƒ±lmasƒ±  |
             
## üìî Java 1. G√ºn
### IDE se√ßimi ve Java‚Äôya ba≈ülangƒ±√ß
Ment√∂r√ºm Hasan Bey Java i√ßin ≈üirkette ve profesyonel hayatta genellikle IntelliJ IDEA kullanƒ±ldƒ±ƒüƒ±nƒ± belirtti, aray√ºz√ºne de ≈üimdiden alƒ±≈ümam i√ßin IDE olarak IntelliJ IDEA‚Äôyƒ± tercih ettik. Uygulamayƒ± bilgisayarƒ±ma indirip kurdum.
Temel bilgileri edindikten sonra `System.out.print()` ve `System.out.println()` gibi output alma fonksiyonlarƒ±nƒ±n kullanƒ±mƒ±nƒ± √∂ƒürendim. Ardƒ±ndan a≈üaƒüƒ±daki gibi ‚Äúhello world!‚Äù benzeri ilk kodlarƒ±mƒ± yazdƒ±m.
```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world!");
        System.out.println("I'm Kadir Kaan.");
        System.out.println("I've finished my " + 2 + "year at Kadir Has University");
        System.out.println("I'm " + (12+8) + " years old.");
    }
}
```

## üìî Java 2. G√ºn
### Java‚Äôda deƒüi≈ükenler, temel veri tipleri, temel operat√∂rler ve control statements
Java‚Äôda temel veri tipleri olarak boolean, char, byte, short, int, long, float, double ve string bulunuyor. C++‚Äôta bulunan unsigned veri tipleri bulunmuyor, ayrƒ±ca C++‚Äôta bulunmayan byte veri tipi Java‚Äôda mevcut. Byte veri tipi tek byte‚Äôlƒ±k tam sayƒ± deƒüerlerini tutmak i√ßin kullanƒ±lƒ±yor.

Temel veri tiplerinden sonra temel operat√∂rler hakkƒ±nda bilgiler edindim. √ñrneƒüin, 
== e≈üittir, != e≈üit deƒüildir, > b√ºy√ºkt√ºr, < k√º√ß√ºkt√ºr, >= b√ºy√ºk e≈üittir, <= k√º√ß√ºk e≈üittir anlamƒ±na gelmekte. Ayrƒ±ca && ve(and), || veya(or), ! deƒüili(not) anlamƒ±na geliyor.

Sonrasƒ±nda control statements hakkƒ±nda bilgi edindim. Bunlar if, else if, else ve switch-case‚Äôdir. Control statements kullanarak a≈üaƒüƒ±daki gibi √∂rnekler yaptƒ±m.

```java
public class Main {
    public static void main(String[] args) {
        boolean flag = true;
        if(flag == true){
            System.out.println("Flag is true.");
        }
        else{
            System.out.println("Flag is false.");
        }

        char grade = 'A';
        switch (grade){
            case 'A':
                System.out.println("Well done!");
                break;
            case 'B':
                System.out.println("Great!");
                break;
            case 'C':
                System.out.println("Good!");
                break;
            case 'D':
                System.out.println("Enough.");
                break;
            case 'F':
                System.out.println("You should work harder!");
                break;
        }
    }
}
```

## üìî Java 3. G√ºn
### Java‚Äôda d√∂ng√ºler, diziler (arrays), string‚Äôler, paketler (packages), kullanƒ±cƒ±dan veri (input) alma
Java'da 3 tip d√∂ng√º bulunuyor. Bunlar For loop, While loop ve Do-While loop. √ú√ß√ºn√ºn de syntax‚Äôi C++ ile aynƒ± olduƒüu i√ßin hƒ±zlƒ±ca uyum saƒülayƒ±p birka√ß √∂rnek sonrasƒ± √∂ƒürenimime diziler (arrays) ile devam ettim.

Diziler, aynƒ± t√ºrden birden fazla deƒüi≈ükeni tutmamƒ±zƒ± saƒülayan hafƒ±za birimidir. Dizi olu≈üturduktan sonra dizinin i√ßerisindeki elemanlara indeks numarasƒ±yla ula≈üabilir ve deƒüi≈ütirebiliriz. Ayrƒ±ca, √ßok boyutlu diziler olu≈üturmak da m√ºmk√ºnd√ºr. ƒ∞ki boyutlu dizilere matris(matrix) denir. K√º√ß√ºk farklƒ±lƒ±klar dƒ±≈üƒ±nda Java‚Äôda dizi olu≈üturma a≈üamalarƒ± ve dizilerle yapƒ±lan i≈ülemler C++ ile olduk√ßa benzer. A≈üaƒüƒ±daki gibi √ße≈üitli √∂rneklerle √∂ƒürendiklerimi peki≈ütirdim.
```java
public class Main {
    public static void main(String[] args) {
        double[] arr = {1.7, 2.6, 9.3, 2.4, 8.4, 3.5};
        System.out.println(Arrays.toString(arr));
        double max = 0;
        double total = 0;
        for(double n : arr){
            if(max < n){
                max = n;
            }
            total += n;
        }
        System.out.println("Total: " + total);
        System.out.println("Max: " + max);
    }
}
```
Ardƒ±ndan Java‚Äôda string sƒ±nƒ±fƒ±nda yapƒ±labilen i≈ülemler hakkƒ±nda bilgi edindim. String sƒ±nƒ±fƒ± `charAt()`, `concat()`, `equals()`, `trim()`, `length()`, `substring()` ve `toLowerCase()` gibi fonksiyonlara sahip. Bu fonksiyonlarƒ±n i≈ülevlerini ve kullanƒ±mlarƒ±nƒ± √∂ƒürenip uyguladƒ±m. A≈üaƒüƒ±daki gibi √∂rnekler yaptƒ±m.
```java
public class Main {
    public static void main(String[] args) {
        String str = "Cristiano Ronaldo";
        System.out.println(str);
        System.out.println(str.charAt(3));
        
        System.out.println("-------");

        str = str.concat(" Portugal");
        System.out.println(str);

        System.out.println("-------");

        System.out.println(str.startsWith("C"));
        System.out.println(str.endsWith("a"));
```       
            
Java‚Äôda proje olu≈ütururken √∂zellikle b√ºy√ºk ve kapsamlƒ± projelerde sƒ±nƒ±flar mantƒ±ksal ve yapƒ±sal durumlarƒ±na g√∂re farklƒ± paketler (packages) altƒ±nda tutulurlar. C++‚Äôtaki k√ºt√ºphaneler gibi Java‚Äôda da Paketler bulunur. Paket Yapƒ±sƒ± kullanƒ±lmasƒ± hem kodun daha d√ºzenli olmasƒ±nƒ± hem kullanƒ±mƒ±n kolay olmasƒ±nƒ± hem de sƒ±nƒ±flarƒ±n birbirleriyle ileti≈üimlerinde meydana gelecek sƒ±nƒ±rlandƒ±rmalarƒ±n ayarlanabilmesini saƒülar. Paket yapƒ±sƒ± aslƒ±nda Java i√ßerisinde dosya yolu tanƒ±mlamaktƒ±r. Olu≈üturduƒüumuz sƒ±nƒ±flarƒ± farklƒ± paketler altƒ±na koymak aslƒ±nda bu sƒ±nƒ±flarƒ± farklƒ± dosya yollarƒ± i√ßerisine kaydetmek demektir. Bu dosya yollarƒ±yla Java hangi sƒ±nƒ±fa nereden eri≈üeceƒüini rahat bir ≈üekilde anlayabilir. Bir paket i√ßinde aynƒ± adƒ± ta≈üƒ±yan iki sƒ±nƒ±f ya da aray√ºz olamaz. Ama, farklƒ± paketler altƒ±nda sƒ±nƒ±f olu≈ütururken aynƒ± isimler kullanƒ±labilir.

Paket olu≈ütururken paket adƒ±ndan hemen √∂nce package anahtar s√∂zc√ºƒü√º yazƒ±lƒ±r. Genellikle sƒ±nƒ±ftan ayƒ±rmak i√ßin paket adlarƒ± k√º√ß√ºk harfle ba≈ülatƒ±lƒ±r. Paketler ba≈üka paketleri import edebilir. Bir paketi dahil edebilmek i√ßin import anahtar kelimesi kullanƒ±lƒ±r. Eƒüer bir paketteki belirli bir alt paketi/sƒ±nƒ±fƒ± import edeceksek, ana paket isminden sonra nokta koyup alt paketin/sƒ±nƒ±fƒ±n adƒ±nƒ± yazarƒ±z. Eƒüer bir alt paketin i√ßindeki her ≈üeyi import etmek istiyorsak noktadan sonra * ekleriz. Ayrƒ±ca, static olarak tanƒ±mlanmƒ±≈ü deƒüi≈üken ve metotlarƒ± sanki import ettiƒüimiz sƒ±nƒ±fƒ±n bir par√ßasƒ±ymƒ±≈ü gibi kullanabilmek i√ßin import static deyimi kullanƒ±lƒ±r.

Paketler hakkƒ±nda bilgi sahibi olduktan sonra kullanƒ±cƒ±dan veri (input) almak hakkƒ±nda bilgi edinmeye ba≈üladƒ±m.

Java‚Äôda kullanƒ±cƒ±dan veri almak i√ßin Scanner sƒ±nƒ±fƒ± kullanƒ±lƒ±r. Ama bu sƒ±nƒ±fƒ± kullanmadan √∂nce kodumuza Scanner sƒ±nƒ±fƒ±nƒ± dahil (import) etmemiz gerekir. Ardƒ±ndan Scanner sƒ±nƒ±fƒ±na ait bir nesne tanƒ±mlanƒ±r ve bu nesnenin fonksiyonlarƒ±yla input alƒ±mƒ± yapƒ±lƒ±r. Alƒ±nacak verinin t√ºr√ºne g√∂re `nextInt()`, `nextDouble()`, `nextLine()` gibi fonksiyonlar kullanƒ±lƒ±r.

Listeler, string‚Äôler, paketler ve input alma hakkƒ±nda √∂ƒürendiklerimi bir araya getirip a≈üaƒüƒ±daki gibi √ße≈üitli uygulamalar olu≈üturdum.
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("Write a number to check: ");
        int num = input.nextInt();

        if(num == 1){
            System.out.println("It is not a prime number.");
            return;
        }
        else if(num <= 0){
            System.out.println("Invalid number.");
            return;
        }
        boolean isPrime = true;
        for(int i = 2; i < num; i++){
            if(num % i == 0){
                isPrime = false;
                break;
            }
        }
        if(isPrime){
            System.out.println("It is a prime number.");
        }
        else{
            System.out.println("It is not a prime number.");
        }
    }
}
```
## üìî Java 4. G√ºn
### Java‚Äôda metotlar (fonksiyonlar), class‚Äôlar (sƒ±nƒ±flar) ve kullanƒ±mlarƒ±
Java'da metotlar sadece √ßaƒürƒ±ldƒ±ƒüƒ±nda kullanƒ±lan kod bloklarƒ±dƒ±r. Bir program i√ßindeki main metodu √ßaƒüƒ±rƒ±larak √ßalƒ±≈ütƒ±rƒ±lƒ±r. Metotlara bir diƒüer adlandƒ±rma olarak fonksiyon da denilmektedir. Bunun sebebi bu kod yapƒ±sƒ±nƒ±n matematikteki fonksiyon mantƒ±ƒüƒ±na √ßok benzemesidir. Java'da metotlarƒ±mƒ±zƒ±n i√ßerisine veri aktarmak i√ßin parametre girebilmekteyiz. Java‚Äôda metotlara girilen parametreler reference olarak deƒüil value olarak aktarƒ±lƒ±yor, yani aktarƒ±lan verinin kendisi deƒüil otomatik olu≈üturulan kopyasƒ± fonksiyonun i√ßinde i≈ülem g√∂r√ºyor. Ayrƒ±ca Java metoda girilecek parametre belirtilirken C++‚Äôta bulunmayan bir √∂zelliƒüe sahip. Bu da veri tipinin yanƒ±na √º√ß nokta koyularak (√∂r: int...) o tipte birden fazla deƒüeri, ka√ß tane olduƒüundan baƒüƒ±msƒ±z olarak metoda yollayabiliyoruz. Yani bu kullanƒ±mla int... olarak belirttiƒüimiz parametreye ka√ß tane integer deƒüeri girmemiz gerektiƒüi hakkƒ±nda bir kƒ±sƒ±tlama yok. 1 tane de girebiliriz 20 tane de. Java bu deƒüerleri alƒ±p bir array‚Äôe √ßeviriyor ve √ºst√ºnde bir array gibi √ßalƒ±≈üƒ±yor. 

Metotlar hakkƒ±nda bilgi sahibi olup birka√ß √∂rnek yaptƒ±ktan sonra Class‚Äôlar √ºzerine √ßalƒ±≈ümaya ba≈üladƒ±m. Java Nesne Y√∂nelimli bir programlama dilidir. Java'daki her ≈üey, deƒüi≈ükenleri ve metotlarƒ± ile birlikte sƒ±nƒ±flar ve nesnelerle ili≈ükilidir. √ñrneƒüin: ger√ßek hayatta araba bir nesnedir. Arabanƒ±n aƒüƒ±rlƒ±k ve renk gibi deƒüi≈ükenleri ve s√ºr√º≈ü ve fren gibi metotlarƒ± vardƒ±r. Nesne y√∂nelimli programlamanƒ±n amacƒ± yazdƒ±ƒüƒ±mƒ±z kodlara soyut bir kavrama d√∂n√º≈üt√ºrmektir. Sƒ±nƒ±flara ait nitelikler ve davranƒ±≈ülar vardƒ±r. Programlamada nitelikler (attributes) i√ßin deƒüi≈ükenler (variable), davranƒ±≈ülar i√ßin ise metotlar tanƒ±mlanƒ±r. Java‚Äôda sƒ±nƒ±f isimleri olu≈üturulan Java dosyasƒ±yla aynƒ± isme sahip olmalƒ±dƒ±r. Java'da nesne √ºretmek i√ßin C++‚Äôta olduƒüu gibi "new" anahtar kelimesini kullanƒ±rƒ±z.

Sƒ±nƒ±flara ait niteliklere eri≈üim saƒülamak i√ßin nokta (.) kullanƒ±lƒ±r. ƒ∞lgili nesnenin ismini sonuna nokta koyularak eri≈üilmek istenilen niteliƒüin ismi yazƒ±lƒ±r. Aynƒ± ≈üekilde, sƒ±nƒ±fa ait davranƒ±≈ülara yani metotlara eri≈ümek i√ßin nokta (.) kullanƒ±lƒ±r. ƒ∞lgili nesnenin ismini sonuna nokta koyularak eri≈üilmek istenilen metodun ismi yazƒ±lƒ±r ve var ise parametreleri girilir.

Ek olarak, SOLID yazƒ±lƒ±m prensibine g√∂re bir metodun veya sƒ±nƒ±fƒ±n yalnƒ±zca bir sorunu √ß√∂zmesi, yapmasƒ± gereken sadece bir i≈üi olmasƒ± gerekir. 

C++ ile olduk√ßa benzer olan Java class syntax‚Äôƒ±na alƒ±≈ümam kolay oldu ve farklƒ± √∂rnek sƒ±nƒ±flar olu≈üturmaya ba≈üladƒ±m. Sonrasƒ±nda ise metotlar ve sƒ±nƒ±flar hakkƒ±nda √∂ƒürendiklerimi birle≈ütirmek ve peki≈ütirmek i√ßin bir basit hesap makinesi sƒ±nƒ±fƒ± yazdƒ±m.
```java
public class Calculator {
    public int sum(int... nums){
        int result = 0;
        for(int num : nums){
            result += num;
        }
        return result;
    }
    public int subtract(int... nums){
        int result = 0;
        for(int num : nums){
            result -= num;
        }
        return result;
    }
    public int multiply(int... nums){
        int result = 1;
        for(int num : nums){
            result *= num;
        }
        return result;
    }
    public double divide(double num1, double num2){
        return num1/num2;
    }
    public int remainder(int num1, int num2){
        return num1%num2;
    }
    public int square(int num){
        return num*num;
    }
}
```

## üìî Java 5. G√ºn
### Yazƒ±lƒ±m prensipleri ve OOP konseptine giri≈ü
‚Ä¢	S.O.L.I.D. tasarƒ±m ilkeleri a≈üaƒüƒ±dakilerden olu≈üur:

S- Single Responsibility Principle (Tek Sorumluluk Prensibi): 
Her mod√ºl (sƒ±nƒ±f, metot vb.), yazƒ±lƒ±mƒ±n saƒüladƒ±ƒüƒ± i≈ülevselliƒüin tek bir par√ßasƒ± √ºzerindeki sorumluluƒüunu yerine getirecek ≈üekilde tasarlanmalƒ±dƒ±r.

O- Open/Closed Principle (A√ßƒ±k/Kapalƒ± Prensibi): 
Geli≈ütirilen yazƒ±lƒ±mdaki nesnelerin geli≈ütirmeye a√ßƒ±k ama deƒüi≈üime kapalƒ± olmasƒ± gerekir. Yazƒ±lƒ±mda herhangi bir g√ºncelleme yapƒ±lmasƒ± durumunda temel nesnenin deƒüi≈üime kapalƒ± tutulmasƒ± gerekir. Bir nesne ek √∂zellik kazandƒ±ysa bu nesne geni≈ületilebilir fakat temel nesne deƒüi≈ütirilmemelidir.

L- Liskov‚Äôs Substitution Principle (Liskov‚Äôun ƒ∞kame ‚ÄúYerine Ge√ßme‚Äù Prensibi): 
Miras alarak t√ºremi≈ü olan sƒ±nƒ±flarƒ±n √∂nce miras aldƒ±klarƒ± nesnenin t√ºm √∂zelliklerini kullanmasƒ±, sonra da kendi √∂zelliklerini barƒ±ndƒ±rmasƒ± gerekir. Eƒüer olu≈üturulan sƒ±nƒ±f, miras aldƒ±ƒüƒ± nesnenin t√ºm √∂zelliklerini kullanmazsa ortaya gereksiz kod bloklarƒ± √ßƒ±kar.

I- Interface Segregation Principle (Aray√ºz Ayrƒ±≈ütƒ±rma Prensibi): 
Bir aray√ºze (interface) gereƒüinden fazla i≈ü y√ºklemek yerine bu i≈üler i√ßin birden fazla aray√ºzler olu≈üturulmalƒ±dƒ±r. Bu prensibin amacƒ± nesnelere, ihtiyacƒ± olmayan √∂zellik veya fonksiyonlar i√ßeren aray√ºz uygulamamaktƒ±r.

D- Dependency Inversion Principle (Baƒüƒ±mlƒ±lƒ±k Tersine √áevirme Prensibi): 
Alt sƒ±nƒ±flarƒ±n √ºst sƒ±nƒ±flarƒ± etkilememesi, sƒ±nƒ±flar arasƒ±ndaki baƒüƒ±mlƒ±lƒ±klarƒ±n olabildiƒüince az olmasƒ± gerekir. √ñzellikle y√ºksek seviyeli sƒ±nƒ±flar, d√º≈ü√ºk seviyeli sƒ±nƒ±flara baƒülƒ± olmamalƒ±dƒ±r.

‚Ä¢	KISS ‚Äî Keep It Simple, Stupid (Basit Tut, Aptal):

‚ÄúKeep It Simple, Stupid‚Äù ilkesi bize t√ºm yazƒ±lƒ±m veya uygulama tasarƒ±mƒ±nƒ±n ve daƒüƒ±tƒ±mƒ±nƒ±n m√ºmk√ºn olduƒüunca basit, en az karma≈üƒ±klƒ±kla ve geli≈ütirme prosed√ºrlerini anlamak i√ßin anla≈üƒ±lƒ±r ≈üekilde yapƒ±lmasƒ± gerektiƒüini hatƒ±rlatƒ±r. Bu ilke, kaynak kodun hata ayƒ±klamasƒ±nƒ±n kolay hale getirilmesini ve gelecekteki herhangi bir operasyon ve bakƒ±mƒ±n (maintenance) daha kolay olmasƒ±nƒ± saƒülar.

‚Ä¢	DRY ‚Äî Don‚Äôt Repeat Yourself (Kendini Tekrar Etme):

‚ÄúDon‚Äôt Repeat Yourself‚Äù ilkesi bize, her yazƒ±lƒ±m m√ºhendisinin, fazlalƒ±klardan ka√ßƒ±nmak i√ßin √ßalƒ±≈ümalarƒ±nda bilgi veya y√∂ntemlerin tekrarƒ±nƒ± azaltmayƒ± hedeflemesi gerektiƒüini s√∂yler. Bu nedenle, t√ºm deƒüerlendirme sistemini par√ßalara ayƒ±rmanƒ±z √∂nerilir. Kodu daha k√º√ß√ºk par√ßalara b√∂lmek, kodu y√∂netmeye ve gerektiƒüinde arayarak herhangi bir noktada tek bir par√ßa kullanmaya yardƒ±mcƒ± olabilir.

Sonrasƒ±nda OOP (Object Oriented Programming / Nesne Y√∂nelimli Programlama) konsepti hakkƒ±nda bilgi sahibi oldum. Nesne Y√∂nelimli Programlama, sƒ±nƒ±flar ve nesneler kavramƒ±na dayanan bir programlama yakla≈üƒ±mƒ±dƒ±r. Bu yakla≈üƒ±mƒ±n amacƒ±, ihtiya√ß duyulan programƒ± daha k√º√ß√ºk par√ßalara b√∂lerek, y√∂netilebilir ve yeniden kullanƒ±labilir hale getirmektir. 

‚Ä¢	OOP, programlar i√ßin net bir yapƒ± saƒülar. DRY, KISS gibi ilkeleri uygular ve kodun bakƒ±mƒ±nƒ±, d√ºzenlenmesini ve hata ayƒ±klamasƒ±nƒ± kolayla≈ütƒ±rƒ±r.

‚Ä¢	OOP, daha az kod ve daha kƒ±sa geli≈ütirme s√ºresiyle, yeniden kullanƒ±labilir uygulamalar olu≈üturmayƒ± m√ºmk√ºn kƒ±lar.

‚Ä¢	OOP, yapƒ±ya daha sonradan yeni √∂zellikler ekleyerek geni≈ületilebilirlik saƒülar.

‚Ä¢	OOP, problemleri ger√ßek hayattaki i≈ülemlere g√∂re modeller.

Nesne Y√∂nelimli Programlama ile bizler yapacaƒüƒ±mƒ±z her ≈üeyi bilgisayarƒ±n anlayacaƒüƒ± ≈üekilde modelleyip, ‚Äúnesne‚Äù halinde aktarƒ±yoruz. B√∂ylelikle ger√ßek hayatta bizim i√ßin ge√ßerli olan nesneleri artƒ±k bilgisayarlarƒ±n anlayacaƒüƒ± hale getirmi≈ü oluyoruz.

## üìî Java 6. G√ºn
### Java‚Äôda OOP - encapsulation (kaps√ºlleme), constructors (yapƒ±cƒ± bloklar) ve Access Modifiers
Encapsulation ilkesi, bir sƒ±nƒ±fa ait deƒüi≈ükenlerin veya niteliklerin ancak o sƒ±nƒ±fa ait metotlar tarafƒ±ndan deƒüi≈ütirilebilmesi ve okunabilmesi ilkesidir. Bu ilke sayesinde nesnelerde olu≈üacak anlamsƒ±zlƒ±klarƒ±n √∂n√ºne ge√ßilebilir.

Ayrƒ±ca deƒüi≈ükenlere sƒ±nƒ±flarƒ±n dƒ±≈üƒ±ndan eri≈üim olmamasƒ± ve bir sƒ±nƒ±f i√ßindeki deƒüi≈ükenlerin nasƒ±l ve ne kadar olacaƒüƒ±nƒ±n da ba≈üka kodlardan saklanmƒ±≈ü olmasƒ± anlamƒ±na gelir. B√∂ylelikle biz deƒüi≈ükenlerimizi sarmalayarak istenmeyen durumlardan korunacak bir filtre haline d√∂n√º≈üt√ºrebiliriz.

Bir sƒ±nƒ±fa ait nitelik ve davranƒ±≈ülara eri≈üebilmek i√ßin Access Modifiers (Eri≈üim Belirleyiciler) kullanƒ±lƒ±r. Java‚Äôda Access Modifiers deƒüi≈üken metot ve sƒ±nƒ±flarƒ±n √∂n√ºne yazƒ±lƒ±r ve yazƒ±ldƒ±klarƒ± konunun eri≈üilebilecekleri alanƒ± belirlerler.

Java‚Äôda 3 adet Access Modifier mevucttur. Bunlar Private, Public ve Protected‚Äôdƒ±r. 

‚Ä¢	Private: yazƒ±ldƒ±ƒüƒ± √∂ƒüenin sadece o sƒ±nƒ±f tarafƒ±ndan eri≈üilebilir olduƒüunu ve o sƒ±nƒ±fƒ±n dƒ±≈üƒ±ndaki kodlardan doƒürudan eri≈üim olmadƒ±ƒüƒ±nƒ± tanƒ±mlar. 
‚Ä¢	Public: yazƒ±ldƒ±ƒüƒ± √∂ƒüenin sadece ait olduƒüu sƒ±nƒ±f i√ßin deƒüil diƒüer sƒ±nƒ±flar tarafƒ±ndan da doƒürudan eri≈üilebilir olmasƒ±nƒ± saƒülar. 
‚Ä¢	Protected: Public ve Private arasƒ±nda kalan eri≈üim d√ºzenleyicidir. Protected ile tanƒ±mlanan √∂ƒüeler kendisi ile aynƒ± pakette (package) bulunan sƒ±nƒ±flar tarafƒ±ndan doƒürudan eri≈üilebilir.

Bir sƒ±nƒ±fa ait private deƒüi≈ükenlere ula≈ümak i√ßin Getter metotlarƒ± kullanƒ±lƒ±r. Bir sƒ±nƒ±fa ait private deƒüi≈ükenlerin deƒüerini deƒüi≈ütirmek i√ßin ise Setter metotlarƒ± kullanƒ±lƒ±r.
```java
public class Product {
    private String name;
    private String description;
    private double price;
    private int id;
    private int stockAmount;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return this.description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public double getPrice() {
        return this.price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public int getId() {
        return this.id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getStockAmount() {
        return this.stockAmount;
    }

    public void setStockAmount(int stockAmount) {
        this.stockAmount = stockAmount;
    }
}
```
           
Yapƒ±cƒ± metotlar sƒ±nƒ±f tasarlanƒ±rken yazƒ±lƒ±rlar. Eƒüer sƒ±nƒ±f i√ßinde hi√ß yapƒ±cƒ± metot tanƒ±mlanmazsa parametresiz bo≈ü bir yapƒ±cƒ± metot Java tarafƒ±ndan otomatik olarak tanƒ±mlanƒ±r. Yapƒ±cƒ± metotlarƒ±n isimleri Sƒ±nƒ±f ismiyle aynƒ± olmak zorundadƒ±r. D√∂n√º≈ü tipi olarak veya void olarak herhangi bir tanƒ±mlama yapƒ±lmasƒ±na gerek yoktur. Sonrasƒ±nda bu sƒ±nƒ±fa ait bir nesne olu≈üturulduƒüunda nesnenin nitelikleri(attributes) null‚Äôa e≈üit olur. 

Yukarƒ±da olu≈üturduƒüum Product sƒ±nƒ±fa bir constructor (yapƒ±cƒ± metot) yazƒ±lmadƒ±ƒüƒ± i√ßin Java otomatik tanƒ±mlanan constructor‚Äôƒ± kullanarak sƒ±nƒ±f i√ßin tanƒ±mlanan niteliklere sahip bir nesne olu≈üturdu ve bu nitelikleri null‚Äôa e≈üitledi. Eƒüer otomatik tanƒ±mlanan yapƒ±cƒ± metotun (default constructor) bizim tanƒ±mladƒ±ƒüƒ±mƒ±z bir constructor varken de kullanƒ±labilmesini istiyorsak parametresiz ve i√ßi bo≈ü bir constructor metodu yazmamƒ±z gerekiyor.
       
Yazdƒ±ƒüƒ±m Product sƒ±nƒ±fƒ±na name, description, stockAmount, price ve id niteliklerinin parametre olarak verildiƒüi bir constructor yazdƒ±m. Default constructor‚Äôƒ±n da kullanƒ±labilir olmasƒ± i√ßin onu da i√ßi bo≈ü bir ≈üekilde tanƒ±mladƒ±m.
```java
Product(){

}
Product(String name, String description, double price, int id, int stockAmount){
    this.name = name;
    this.description = description;
    this.price = price;
    this.id = id;
    this.stockAmount = stockAmount;
}    
```

## üìî Java 7. G√ºn
### Java‚Äôda OOP ‚Äì Inheritance (kalƒ±tƒ±m) ve metot overloading (a≈üƒ±rƒ± y√ºklenme)
Java‚Äôda bir metodu farklƒ± t√ºrde, sayƒ±da veya sƒ±rada parametre ile olu≈üturmak istiyorsak yani aynƒ± metodun farklƒ± versiyonlarƒ± olu≈üturulmak isteniyorsa metotlara overloading (a≈üƒ±rƒ± y√ºkleme) yapƒ±lƒ±r. Metotlar aynƒ± isme sahip olur ancak parametreleri farklƒ±lƒ±k g√∂sterir. Farklƒ± constructor metotlarƒ± olu≈üturmaya benzer.

A≈üaƒüƒ±daki √∂rnekte bir example fonksiyonu tanƒ±mladƒ±m ve overloading ile √º√ß farklƒ± versiyonunu olu≈üturdum.
```java
    public static int example(int a, int b){
        return a + b;
    }
    public static int example(int a, int b, int c){
        return a + b - c;
    }
    public static int example(int a, int b, int c, int d){
        return a * b + c - d;
    }
```

       
Bir sƒ±nƒ±fƒ±n ba≈üka bir sƒ±nƒ±ftan kalƒ±tƒ±m yapmasƒ± (inheritance) demek, kalƒ±tƒ±mƒ± yapan sƒ±nƒ±fƒ±n diƒüer sƒ±nƒ±ftaki nitelik ve davranƒ±≈ülarƒ±nƒ± (metotlarƒ±nƒ±) kendisine almasƒ±, kullanabilmesi demektir. Kalƒ±tƒ±mƒ± yapan sƒ±nƒ±fa alt sƒ±nƒ±f, kendisinden kalƒ±tƒ±m yapƒ±lan sƒ±nƒ±fa ata sƒ±nƒ±f dersek, ata sƒ±nƒ±fta tanƒ±mlƒ± olan her ≈üeyin alt sƒ±nƒ±f i√ßin de tanƒ±mlƒ± olduƒüunu s√∂yleyebiliriz. Kalƒ±tƒ±m Java‚Äôda ‚Äúextends‚Äù kelimesi ile tanƒ±mlanƒ±r. √ñrneƒüin A sƒ±nƒ±fƒ±nƒ±n B sƒ±nƒ±fƒ±ndan kalƒ±tƒ±m yapmasƒ±nƒ± istiyorsak A sƒ±nƒ±fƒ±nƒ± tanƒ±mlarken ‚Äúpublic Class A extends B‚Äù ≈üeklinde yazarƒ±z.

Kalƒ±tƒ±mƒ±n kavramƒ±nƒ±n bir√ßok farklƒ± t√ºr√º bulunmakta:

‚Ä¢	Tek Y√∂nl√º Kalƒ±tƒ±m (Single Inheritance): Bir sƒ±nƒ±fƒ±n ba≈üka bir sƒ±nƒ±fƒ± geni≈ülettiƒüi, alt ve ata sƒ±nƒ±f ili≈ükisini ifade eder.

‚Ä¢	√áoklu Kalƒ±tƒ±m (Multiple Inheritance): Bir sƒ±nƒ±fƒ±n birden fazla sƒ±nƒ±fƒ± miras almasƒ±nƒ± ifade eder. Yani bir alt sƒ±nƒ±fƒ±n iki ata sƒ±nƒ±fa sahip olduƒüu anlamƒ±na gelir. Java multiple inheritance‚Äôƒ± desteklemez.

‚Ä¢	√áok Seviyeli Kalƒ±tƒ±m (Multilevel Inheritance): Bir sƒ±nƒ±fa ait alt sƒ±nƒ±fƒ±n ba≈üka sƒ±nƒ±flarƒ± geni≈ületmesine denir.

‚Ä¢	Hiyerar≈üik Kalƒ±tƒ±m (Hierarchical Inheritance): Birden fazla sƒ±nƒ±fƒ±n aynƒ± sƒ±nƒ±fƒ± geni≈ülettiƒüi bir alt ve √ºst sƒ±nƒ±f ili≈ükisini ifade eder. Yani bir ata sƒ±nƒ±fƒ±n birden √ßok alt sƒ±nƒ±fƒ± vardƒ±r.

‚Ä¢	Hibrit Kalƒ±tƒ±m (Hybrid Inheritance): Programda birden fazla kalƒ±tƒ±m t√ºr√ºn√ºn kombinasyonuna denir. √ñrneƒüin, A ve B sƒ±nƒ±fƒ±, C sƒ±nƒ±fƒ±nƒ± geni≈ületir ve ba≈üka bir D sƒ±nƒ±fƒ±, A sƒ±nƒ±fƒ±nƒ± geni≈ületir, bu bir hibrit kalƒ±tƒ±m √∂rneƒüidir √ß√ºnk√º bu durum tek y√∂nl√º ve hiyerar≈üik kalƒ±tƒ±mƒ±n bir birle≈üimidir.

Ek olarak, ata sƒ±nƒ±fƒ±n tipinde tanƒ±mlanan bir parametreye, o ata sƒ±nƒ±fƒ±n alt sƒ±nƒ±flarƒ±nƒ±n tipinde bir deƒüi≈üken yazƒ±lƒ±rsa kod sorunsuz √ßalƒ±≈üƒ±r √ß√ºnk√º alt sƒ±nƒ±flar ata sƒ±nƒ±fƒ±n da √∂zelliklerini i√ßerir.
A≈üaƒüƒ±daki √∂rnekte bir A sƒ±nƒ±fƒ± tanƒ±mladƒ±m. Sonrasƒ±nda A sƒ±nƒ±fƒ±nƒ±n alt sƒ±nƒ±fƒ± olan bir B sƒ±nƒ±fƒ± tanƒ±mladƒ±m. Sonra da B sƒ±nƒ±fƒ±nƒ±n alt sƒ±nƒ±fƒ± olan C sƒ±nƒ±fƒ± tanƒ±mladƒ±m.
```java
public class A {
    public int sum(int n, int m){
        return n + m;
    }
}
```
```java
public class B extends A{
    public int multiplication(int n, int m){
        return n * m;
    }
}
```
```java
public class C extends B{
    public int remainder(int n, int m){
        return n % m;
    }
}
```
C sƒ±nƒ±fƒ±ndan olu≈üturduƒüum nesneyle A ve B sƒ±nƒ±flarƒ±nƒ±n fonksiyonlarƒ±nƒ± √ßalƒ±≈ütƒ±rabildim. Ardƒ±ndan B sƒ±nƒ±fƒ±ndan olu≈üturduƒüum nesneyle de A sƒ±nƒ±fƒ±nƒ±n `sum()` metodunu kullanabildim. √á√ºnk√º C sƒ±nƒ±fƒ± B‚Äônin, B sƒ±nƒ±fƒ± da A‚Äônƒ±n alt sƒ±nƒ±fƒ±.

## üìî Java 8. G√ºn
### Java‚Äôda OOP ‚Äì Polymorphism (√ßok bi√ßimlilik), method overriding (metot ezme/ge√ßersiz kƒ±lma), Abstraction ve Abstract Class‚Äôlar (soyut sƒ±nƒ±f)
Polymorphism bir √ºst sƒ±nƒ±f referansƒ±nƒ±n t√ºm alt sƒ±nƒ±f nesnelerini tutabilmesidir. Yani bir √ºst sƒ±nƒ±f referansƒ±na tanƒ±mlanan bir deƒüeri, o sƒ±nƒ±fƒ±n alt sƒ±nƒ±flarƒ±nƒ±n tipinde deƒüi≈ükenler yazarak √ßalƒ±≈ütƒ±rabiliriz.
	
Ayrƒ±ca Polymorphism, alt sƒ±nƒ±flarƒ±n ata sƒ±nƒ±flardaki metotlarƒ± method overriding sayesinde ge√ßersiz kƒ±lmasƒ±, √ßok bi√ßimli olarak davranmasƒ±na denir. Bu sayede alt sƒ±nƒ±f ata sƒ±nƒ±fƒ±ndan gelen davranƒ±≈üƒ± kendine g√∂re ≈üekillendirebilir.

Method overriding (metot ezme/ge√ßersiz kƒ±lma) bir alt sƒ±nƒ±fƒ±n i√ßine, doƒürudan ya da dolaylƒ± olarak ata sƒ±nƒ±flarƒ±ndan gelen bir y√∂ntemin aynƒ±sƒ±nƒ±n, aynƒ± y√∂ntem adƒ± ve aynƒ± parametrelere sahip olarak, kodlanmasƒ±na verilen addƒ±r. Java‚Äôda bu i≈ülem metottan √∂nce yazƒ±lan @Override ifadesi ile kullanƒ±lƒ±r. Eƒüer bir metodun override edilememesi isteniyorsa, bu metot final ifadesi kullanƒ±larak tanƒ±mlanƒ±r.

Polymorphism sayesinde uygulamalarƒ±n geni≈ületilebilirliƒüini saƒülarƒ±z. Ata sƒ±nƒ±fƒ±n sunduƒüu y√∂ntemleri ge√ßersiz kƒ±lan alt sƒ±nƒ±flar yardƒ±mƒ± ile ata sƒ±nƒ±fa g√∂re kodlanmƒ±≈ü bir kod kesimine (metot vb.) farklƒ± davranƒ±≈ülar y√ºkleme imkanƒ±mƒ±z olmaktadƒ±r. Yani, elimizde esnek bir altyapƒ± var denebilir. 

A≈üaƒüƒ±daki √∂rnekte Polymorphism ve overriding‚Äôi birlikte kullanarak bir kredi hesaplama programƒ± yazdƒ±m. Bu programda BaseLoanManager adƒ±nda bir ata sƒ±nƒ±f ve bu sƒ±nƒ±fƒ±n alt sƒ±nƒ±flarƒ± olan AgricultureLoanManager, StudentLoanManager, TeacherLoanManager sƒ±nƒ±flarƒ±nƒ± yazdƒ±m.

Base sƒ±nƒ±fa faiz oranƒ±nƒ± 1,18 olarak tanƒ±mladƒ±m ve bir calculate (hesaplama) metodu yazdƒ±m. Diƒüer alt sƒ±nƒ±flar i√ßin de hesaplama metodunu override ettim ve hesaplamalarƒ± farklƒ± faiz oranlarƒ± ile yaptƒ±m.
```java
public class BaseLoanManager {
    public double calculate(double amount){
        return amount * 1.18;
    }
}
```
```java
public class AgricultureLoanManager extends BaseLoanManager{
    @Override
    public double calculate(double amount){
        return amount * 1.15;
    }
}
```
```java
public class StudentLoanManager extends BaseLoanManager{
    @Override
    public double calculate(double amount){
        return amount * 1.10;
    }
}
```
```java
public class TeacherLoanManager extends BaseLoanManager{
    @Override
    public double calculate(double amount) {
        return amount * 1.13;
    }
}
```
        
Abstraction (soyutlama), bir sƒ±nƒ±fa veya metoda temel g√∂revlerin tanƒ±mlanmasƒ±, detaylarƒ±n ise tanƒ±mlanmamasƒ± demektir. Temel olarak bir soruna ait √ß√∂z√ºme giderken kullanƒ±lacak y√∂ntemlerin, ilk etapta daha genel basit ve soyut bir tanƒ±mƒ±nƒ± yapmaktƒ±r. Alt sƒ±nƒ±flarƒ±n ortak √∂zelliklerini ve i≈ülevlerini ta≈üƒ±yan ancak hen√ºz bir nesnesi olmayan bir √ºst sƒ±nƒ±f olu≈üturmak istenirse bir abstract (soyut) √ºst sƒ±nƒ±f olu≈üturulur. Soyutlama i√ßin Java'da iki y√∂ntem mevcuttur: abstract sƒ±nƒ±f tanƒ±mlamak ve interface tanƒ±mlamak.

Abstract sƒ±nƒ±flar, "abstract" anahtar kelimesi ile tanƒ±mlanan sƒ±nƒ±flardƒ±r. Sƒ±nƒ±fƒ±n i√ßinde soyut (abstract) metotlar veya normal metotlar tanƒ±mlanabilir. Abstract olarak tanƒ±mlanan metotlarƒ±n abstract sƒ±nƒ±f i√ßinde tanƒ±mƒ± yapƒ±lmaz ve inherit eden alt sƒ±nƒ±flarda √∂zel olarak tanƒ±mlarƒ±nƒ±n yapƒ±lmasƒ± gerekir. Ayrƒ±ca soyut sƒ±nƒ±flardan new anahtar kelimesi ile bir nesne olu≈üturulamaz. Abstract sƒ±nƒ±flar da polymorphism √∂zelliƒüi sayesinde alt sƒ±nƒ±flarƒ±nƒ±n referansƒ±nƒ± tutabilirler.

A≈üaƒüƒ±daki √∂rnekte abstract class‚Äôlarƒ± kullanarak bir prototip Database Manager √∂rneƒüi olu≈üturdum. Bunun i√ßin bir abstract BaseDatabaseManager sƒ±nƒ±fƒ± olu≈üturdum. Farklƒ± SQL server‚Äôlarƒ±n farklƒ± kodlarƒ± olabildiƒüi i√ßin abstract olarak olu≈üturduƒüum bu √ºst sƒ±nƒ±fta getData adlƒ± bir abstract metot olu≈üturdum. B√∂ylece spesifik SQL server tiplerini kullanmak i√ßin olu≈üturulacak alt sƒ±nƒ±flarda, getData metodunun kodlarƒ±nƒ±n o server tipi i√ßin √∂zel olarak tanƒ±mlanmasƒ± gerekecektir. Ardƒ±ndan bir de CustomerManager sƒ±nƒ±fƒ± olu≈üturdum. Burada ama√ß CustomerManager sƒ±nƒ±fƒ±nƒ±n i√ßindeki getCustomers metodunu kullanarak SQL server‚Äôlardan m√º≈üteri verisi √ßeken bir prototip uygulama yapmak. √ñrnek alt sƒ±nƒ±f olarak da OracleDatabaseManager ve MySqlDatabaseManager sƒ±nƒ±flarƒ±nƒ± olu≈üturdum.
```java
public abstract class BaseDatabaseManager {
    public abstract void getData();
}
```
```java
public class OracleDatabaseManager extends BaseDatabaseManager{
    @Override
    public void getData() {
        System.out.println("Getting the data - Oracle...");
        //Oracle database codes
    }
}
```
```java
public class MySqlDatabaseManager extends BaseDatabaseManager{
    @Override
    public void getData() {
        System.out.println("Getting the data - MySql...");
        //MySql database codes
    }
}
```
```java
public class CustomerManager {
    BaseDatabaseManager databaseManager;

    public void getCustomers(){
        databaseManager.getData();
    }
}
```

## üìî Java 9. G√ºn
### Java‚Äôda OOP ‚Äì Interface (aray√ºzler), Inner Class ve Static terimi
Java'da soyutlamayƒ± saƒülamanƒ±n bir ba≈üka yolu da interface tanƒ±mlamaktƒ±r. 
Interface'lerin abstract class‚Äôlara g√∂re soyutlama oranƒ± √ßok y√ºksektir. √á√ºnk√º, abstract class‚Äôlarda soyut olmayan fonksiyonlar da tanƒ±mlanabilirken, interface‚Äôler i√ßinde sadece soyut fonksiyonlar tanƒ±mlanabiliyor. Metot g√∂vdesi olan normal fonksiyonlar tanƒ±mlanamƒ±yor. Bu soyut metotlarƒ±n implement eden sƒ±nƒ±flar tarafƒ±ndan, aynƒ± abstract class‚Äôlarda olduƒüu gibi, √∂zel olarak tanƒ±mlanmasƒ± gerekiyor. Bir sƒ±nƒ±f bir interface‚Äôden kalƒ±tƒ±m alƒ±yorsa implements anahtar kelimesi kullanƒ±lƒ±r.

Bir sƒ±nƒ±f birden fazla interface‚Äôi inherit olarak alabilir (implement) ancak birden fazla abstract class‚Äôƒ± inherit alamaz (extend). Ayrƒ±ca, Abstract class‚Äôlarda t√ºm √∂ƒüelerin ‚Äúpublic‚Äù olmasƒ± zorunlu deƒüilken Interface i√ßerisindeki t√ºm nesnelerin public olmasƒ± gerekir. Abstract class‚Äôlarda olduƒüu gibi interface‚Äôlerde de new anahtar kelimesi ile nesne olu≈üturulamaz. Ayrƒ±ca interface‚Äôde tanƒ±mlanan deƒüi≈ükenler interface‚Äôi √ßaƒüƒ±ran sƒ±nƒ±f tarafƒ±ndan deƒüi≈ütirilemezler. Interface‚Äôler de Abstract class‚Äôlar gibi polymorphism √∂zelliƒüi ile implement edildikleri sƒ±nƒ±fƒ±n referansƒ±nƒ± tutabilirler.

Ek olarak, genellikle interface isimlerinin ba≈üƒ±na kodun okunurluƒüunun artmasƒ± i√ßin I harfi yazƒ±lƒ±r. 

Interface hakkƒ±nda bilgi edindikten sonra √∂rnekler yapmaya ba≈üladƒ±m. A≈üaƒüƒ±daki √∂rnekte bir firmanƒ±n √ßalƒ±≈üanlarƒ±nƒ±n durumlarƒ±na g√∂re interface implement ettiƒüi √ßalƒ±≈üan sƒ±nƒ±flarƒ± olu≈üturdum. Kafein Yazƒ±lƒ±m gibi firmalardan outsource olarak √ßalƒ±≈üan ki≈üiler i√ßin OutsourceWorker, firmanƒ±n kendi √ßalƒ±≈üanlarƒ± i√ßin Worker sƒ±nƒ±flarƒ± olu≈üturdum. Sonrasƒ±nda bu sƒ±nƒ±flar i√ßin firma b√ºnyesinde √ßalƒ±≈üƒ±yor ise IWorkable interface‚Äôini, yemek masraflarƒ± firma tarafƒ±ndan kar≈üƒ±lanƒ±yorsa IEatable interface‚Äôini, maa≈üƒ± firma tarafƒ±ndan √∂deniyorsa IPayable interface‚Äôini, ikramiye/√∂d√ºllendirme var ise IRewardable interface‚Äôini implement ettim.
```java
public interface IWorkable {
    void work();
    void workingHours();
}
```
```java
public interface IEatable {
    void eat();
}
```
```java
public interface IPayable {
    void pay();
}
```
```java
public interface IRewardable {
    void reward();
}
```
```java
public class Worker implements IWorkable, IPayable, IEatable, IRewardable{
    @Override
    public void work() {
        //works for us
    }
    @Override
    public void workingHours() {
        System.out.println("Works 9am to 6pm");
    }
    @Override
    public void pay() {
        //we pay their salary
    }
    @Override
    public void eat() {
        //we pay for their food expenses
    }
    @Override
    public void reward() {
        //we give them rewards
    }
}
```
```java
public class OutsourceWorker implements IWorkable, IEatable {
    @Override
    public void work() {
        //works for us by outsourcing
    }
    @Override
    public void workingHours() {
        System.out.println("Works 10am to 5pm");
    }
    @Override
    public void eat() {
        //we pay for their food expenses
    }
}
```
        
Java'da Static deyimi, sƒ±nƒ±f deƒüi≈ükenlerini veya sƒ±nƒ±f metotlarƒ±nƒ± tanƒ±mlarken kullanƒ±lƒ±r. Eƒüer bir sƒ±nƒ±fa ait deƒüi≈ükenlerin ba≈üƒ±na static yazƒ±lƒ±rsa, o deƒüi≈ükenler artƒ±k sƒ±nƒ±f deƒüi≈ükeni olurlar. Sƒ±nƒ±f deƒüi≈ükeni olarak tanƒ±mlanan deƒüi≈ükenler, her nesne olu≈üturduƒüumuzda ayrƒ± ayrƒ± olu≈ümazlar. Sƒ±nƒ±fa ait ne kadar nesne olursa olsun, sƒ±nƒ±f deƒüi≈ükenleri bir tanedir. Sƒ±nƒ±fa ait herhangi bir nesne √ºzerinden bu deƒüi≈ükene ula≈üƒ±labilir. Yani, static deƒüerler sƒ±nƒ±fa ait iken static olmayan deƒüerler o sƒ±nƒ±fƒ±n nesnelerine aittir denebilir. Static deƒüerlere sƒ±nƒ±f isminin yanƒ±na nokta koyularak eri≈üilirken (√∂r: `Class.staticVar()`), static olmayan deƒüerlere ait olduklarƒ± nesne isminin yanƒ±na nokta koyularak eri≈üilir (√∂r: `object.nonstaticVar()`). Sƒ±nƒ±f deƒüi≈ükenlerinin bir diƒüer √∂zelliƒüi ise, ilgili sƒ±nƒ±fa ait hi√ß nesne olu≈üturulmasa bile bellekte yer kaplarlar.

√ñte yandan, eƒüer sƒ±nƒ±fa ait metotlardan bir ya da birden fazlasƒ±nƒ±n √∂n√ºne static deyimi yazƒ±lƒ±rsa, o metotlar sƒ±nƒ±f metodu olurlar. Sƒ±nƒ±f metotlarƒ±nƒ±n en √∂nemli √∂zelliƒüi, ilgili sƒ±nƒ±fa ait nesne olu≈üturulmadan √ßaƒüƒ±rƒ±labilir olmalarƒ±dƒ±r. Bu durumda, nesne var olmadan √ßaƒürƒ±labilecek olan sƒ±nƒ±f metotlarƒ±nƒ±n, nesne var olmadan bellekte var olamayan nesne deƒüi≈ükenlerine eri≈ümesi olanaklƒ± deƒüildir. Kƒ±saca, static deƒüerler sadece static deƒüerleri √ßaƒüƒ±rabilir ve kullanabilir. Static olmayan deƒüerler de sadece static olmayan deƒüerleri √ßaƒüƒ±rƒ±p kullanabilir. Yani, new anahtar kelimesi ile olu≈üturulan bir nesne, ait olduƒüu sƒ±nƒ±fƒ±n static metotlarƒ±na eri≈üemez. Benzer ≈üekilde, static olmayan metotlara da bir nesne olu≈üturmadan eri≈üemeyiz.

Java‚Äôda outer class‚Äôlar static olamazken, inner class‚Äôlar (bir sƒ±nƒ±fƒ±n i√ßinde bulunan sƒ±nƒ±flar) static olabilirler. ƒ∞√ß i√ße tanƒ±mlanan sƒ±nƒ±flarƒ± tabir ederken, diƒüerini kapsayan sƒ±nƒ±fa dƒ±≈ütaki sƒ±nƒ±f (outer class), i√ßeride bulunan sƒ±nƒ±fa ise i√ßteki sƒ±nƒ±f (inner class) denir. ƒ∞√ß i√ße sƒ±nƒ±flarda, i√ßteki sƒ±nƒ±fƒ± kullanabilmemiz i√ßin dƒ±≈ütaki sƒ±nƒ±fƒ±n bir √∂rneƒüinin alƒ±nmasƒ± gerekir.

ƒ∞√ßteki sƒ±nƒ±f, dƒ±≈ütaki sƒ±nƒ±fƒ±n b√ºt√ºn alanlarƒ±na ve metotlarƒ±na eri≈üebilir. Dƒ±≈ütaki sƒ±nƒ±f tek olmasƒ±na raƒümen, i√ßteki sƒ±nƒ±fƒ±n birden fazla √∂rneƒüi alƒ±nabilir; bu gibi durumlarda i√ßteki sƒ±nƒ±ftan olu≈üturulan nesnelerin hepsi aynƒ± dƒ±≈ütaki sƒ±nƒ±fa eri≈üir

## üìî Java 10. G√ºn
### Java‚Äôda Collections (Koleksiyonlar) ‚Äì ArrayList ve Hashmap ve Java‚Äôda Exception Handling
Java Collections (Koleksiyonlar), nesne grubunu depolamak veya i≈ülem yapma gibi i≈ülemleri saƒülayan bir t√ºrd√ºr. Genel itibariyle Set, List ve Map olmak √ºzere 3 temel t√ºrden olu≈ümaktadƒ±r. Bunlara Collection Framework denmektedir. Java Collections veri depolamak, veri silmek, veri ekleme ve depolanan verileri i√ßerisinde veri aramak gibi i≈ülemler i√ßin kullanƒ±lƒ±rlar.

List koleksiyon t√ºr√ºnden t√ºremi≈ü bir alt sƒ±nƒ±f olan ArrayList, liste halindeki verileri dinamik diziler(array) kullanarak saklar. Default boyutu 10‚Äôdur. Bu dizilere yeni eleman eklendik√ße eƒüer boyutu yetmiyorsa, √ßalƒ±≈üma zamanƒ±nda, arka tarafta var olan dizinin boyutunun 2 katƒ± olan yeni dizi tanƒ±mlanƒ±r. Eski dizideki elemanlar index deƒüerleri korunarak yeni diziye aktarƒ±lƒ±rlar. ArrayList sƒ±nƒ±fƒ±nƒ± kullanabilmek i√ßin java.util.ArrayList paketini import etmemiz gerekir.

ArrayList sƒ±nƒ±fƒ±, C++‚Äôtaki vector‚Äôlere kar≈üƒ±lƒ±k geliyor denebilir. Ancak vector‚Äôlerden farklƒ± olarak type-safe olmadan (non-generic) da yazƒ±labilir. Yani, array‚Äôin hangi tipte veri alacaƒüƒ± belirtilmezse array her t√ºrden veriyi saklayabilir. Ayrƒ±ca, ArrayListler kendi olu≈üturduƒüumuz sƒ±nƒ±fƒ±n t√ºr√ºnde de deƒüerler tutabilirler.

ArrayList sƒ±nƒ±fƒ± `get()`, `remove()`, `indexOf()` gibi fonksiyonlar barƒ±ndƒ±rƒ±r. Bu fonksiyonlarƒ±n bazƒ±larƒ±nƒ±n isimleri C++‚Äôtaki vector yapƒ±sƒ±nƒ±n fonksiyonlarƒ±ndan farklƒ± olsa da aynƒ± i≈ülemleri ger√ßekle≈ütiriyorlar. 

Ek olarak, non-generic ArrayList‚Äôlerde for-each d√∂ng√ºs√º yapƒ±lƒ±rken iterator‚Äôƒ±n veri tipine Object yazƒ±lƒ±r.
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList list1 = new ArrayList();
        list1.add(5);
        list1.add("ƒ∞stanbul");
        list1.add('a');
        list1.add(3.2);
        list1.remove(2);

        for(Object obj : list1){
            System.out.println(obj);
        }

        System.out.println("---------");

        ArrayList<Integer> list2 = new ArrayList<Integer>();
        list2.add(5);
        list2.add(6);
        list2.add(7);
        list2.add(8);
        list2.remove(2);

        for(int n : list2){
            System.out.println(n);
        }

        System.out.println(list2.indexOf(8));
    }
}
```
       
HashMap sƒ±nƒ±fƒ±, verileri key ‚Äì value (anahtar ‚Äì deƒüer) √ßiftleri olarak saklar. Key ile value‚Äônun aynƒ± tipte olmasƒ±na gerek yoktur. ƒ∞kisi de herhangi bir t√ºrde olabilir. Key deƒüerleri bir index gibi √ßalƒ±≈üƒ±r diyebiliriz. Bir HashMap deƒüerine(value) ula≈ümak i√ßin anahtarƒ±nƒ± bilmemiz gerekir. HashMap, yinelenen deƒüerlere izin verir, ancak yinelenen anahtarlara izin vermez. HashMap sƒ±nƒ±fƒ±nƒ± kullanabilmek i√ßin java.util.HashMap paketini import etmemiz gerekir.

HashMap sƒ±nƒ±fƒ± keySet(), get(), containsKey(), containsValue() gibi metotlar i√ßerir. Java‚Äôdaki HashMap sƒ±nƒ±fƒ± C++‚Äôtaki unordered_map yapƒ±sƒ±na kar≈üƒ±lƒ±k geliyor denebilir. ArrayList sƒ±nƒ±fƒ±ndaki gibi bu fonksiyonlarƒ±n bazƒ±larƒ±nƒ±n isimleri C++‚Äôtaki unordered_map yapƒ±sƒ±nƒ±n fonksiyonlarƒ±ndan farklƒ± olsa da aynƒ± i≈ülemleri ger√ßekle≈ütiriyorlar.
```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        HashMap<String, Integer> hashTable = new HashMap<>();
        hashTable.put("ƒ∞stanbul", 34);
        hashTable.put("Trabzon", 61);
        hashTable.put("Sinop", 57);

        for(String n : hashTable.keySet()){
            System.out.println(hashTable.get(n));
        }
        System.out.println("------");
        System.out.println(hashTable.get("Trabzon"));

        hashTable.remove("Trabzon");
        System.out.println(hashTable);
    }
}
```
       
Java‚Äônƒ±n Exception Handling (hata y√∂netimi) mekanizmasƒ± ≈üu ≈üekilde i≈üler: Programƒ±n √ßalƒ±≈ümasƒ± sƒ±rasƒ±nda istisnai bir durum olu≈üursa bu durumla ilgili bir nesne olu≈üturulur ve throws deyimiyle fƒ±rlatƒ±lƒ±r. B√∂yle bir durumda, programƒ±n olaƒüan akƒ±≈üƒ± durdurulur ve bu hatanƒ±n yakalanmasƒ± beklenir. Hatanƒ±n yakalanabilmesi i√ßin, hataya sebep olan kodun try-catch bloƒüu i√ßine yazƒ±lmasƒ± gerekir. Bu durumda Java √ßalƒ±≈üma ortamƒ±, meydana gelen hatayƒ± yakalayabilecek bir catch bloƒüu arar, eƒüer bulursa bu catch bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±r. Son olarak, eƒüer bir finally bloƒüu yazƒ±lmƒ±≈üsa bu blok √ßalƒ±≈ütƒ±rƒ±lƒ±r ve program normal akƒ±≈üƒ±na devam eder. try bloƒüu i√ßindeki kod bloƒüu hata alsƒ±n ya da almasƒ±n "finally" bloƒüu her ko≈üulda √ßalƒ±≈ütƒ±rƒ±lƒ±r ve opsiyoneldir.

Hata durumlarƒ±nƒ± y√∂netmek i√ßin 2 y√∂ntem vardƒ±r. Try-catch bloklarƒ± ile hatayƒ± alƒ±nacaƒüƒ± tahmin edilen yerde kontrol altƒ±na alabiliriz veya hatayƒ± throws anahtar kelimesi ile √ßaƒürƒ±ldƒ±ƒüƒ± bir √ºst noktaya fƒ±rlatarak, √ß√∂z√ºm√ºn orada yapƒ±lmasƒ±nƒ± zorunlu hale getiririz. throws ifadesine sahip bir metodun, ya √ßaƒürƒ±ldƒ±ƒüƒ± zaman try-catch bloƒüu i√ßerisinde √ßaƒüƒ±rƒ±lmalƒ±dƒ±r ya da √ßaƒüƒ±ran metoda throws anahtar kelimesi eklenmelidir. Ayrƒ±ca Java‚Äôda Exception ata sƒ±nƒ±fƒ±nƒ± t√ºreterek kendi exception‚Äôlarƒ±mƒ±zƒ± yazabiliyoruz.

```java
public class BalanceInsufficientException extends Exception{
    String message;

    public BalanceInsufficientException(String message){
        this.message = message;
    }

    @Override
    public String getMessage() {
        return this.message;
    }
}
```
```java
public class AccountManager {
    private double balance;

    public void deposit(double amount){
        balance = getBalance() + amount;
    }

    public void withdraw(double amount) throws BalanceInsufficientException{
        if(amount < getBalance()){
           balance = getBalance() - amount;
        }
        else{
            throw new BalanceInsufficientException("Insufficient Balance!");
        }
    }

    public double getBalance() {
        return balance;
    }
}
```

## üìî Java 11. G√ºn
### Java‚Äôda Generics ve Threading

Generics (Jenerikler), kelime anlamƒ± itibariyle parametrelendirilmi≈ü t√ºr anlamƒ±na gelir. Jenerikler sayesinde, sƒ±nƒ±f, aray√ºz veya metot yazarken tek bir t√ºre baƒülƒ± kalmayƒ±p √ºzerinde i≈ülem yapacaƒüƒ±nƒ±z t√ºr√º parametre olarak alabilirsiniz. Bu sayede, farklƒ± t√ºrler √ºzerinde √ßalƒ±≈üan tek bir sƒ±nƒ±f yazmak m√ºmk√ºnd√ºr. Bu ≈üekilde yazƒ±lan sƒ±nƒ±flara Generic Class, metotlara Generic Method denir.

Jenerikler, Class ve Interface‚Äôlerin tanƒ±mƒ±nda kullanƒ±lƒ±rken class/interface‚Äôin isminden sonra < ve > i≈üaretleri yazƒ±lƒ±r ve bu i≈üaretlerin ortasƒ±na t√ºr i√ßin bir deƒüi≈üken ismi yazƒ±lƒ±r. Genelde bunun i√ßin T harfi kullanƒ±lƒ±r (√∂r: <T>). Ardƒ±ndan yalnƒ±zca belirttiƒüimiz t√ºr√ºn ve alt sƒ±nƒ±flarƒ±nƒ±n kullanƒ±labilmesi isteniyorsa veya t√ºr√ºn bir interface‚Äôi implement etmesi isteniyorsa extends anahtar s√∂zc√ºƒü√º kullanƒ±lƒ±r. √ñte yandan yalnƒ±zca belirttiƒüimiz t√ºr√ºn ve √ºst sƒ±nƒ±flarƒ±nƒ±n kullanƒ±labilmesi isteniyorsa i√ßin super anahtar kelimesi kullanƒ±lƒ±r.

Generic metotlar tanƒ±mlanƒ±rken ise metotun Acces Modifier‚Äôƒ± (public vb.) yazƒ±ldƒ±ktan sonra, metodun d√∂n√º≈ü t√ºp√º ve isminden √∂nce aynƒ± yazƒ±m(<T>) kullanƒ±lƒ±r.

Jenerikler JDK 5 ile dile eklenmi≈ütir. Buna raƒümen, Java‚Äônƒ±n en temel √∂zelliklerinden biridir ve dili temelden etkilemi≈ütir. Jenerikler, bir yandan farklƒ± t√ºrler i√ßin tek bir kod yazmamƒ±zƒ± saƒülarken, diƒüer yandan t√ºr g√ºvenliƒüini saƒülar.
```java
public interface IDatabaseManager<T extends Student> {
    void add(T item);
    void remove(T item);
    void update(T item);
    T get(int id);
}
```
```java
import java.util.ArrayList;

public class StudentDatabaseManager implements IDatabaseManager<Student>{
    @Override
    public void add(Student item) {
        //Database codes
        System.out.println("Added to the database.");
    }
    @Override
    public void remove(Student item) {
        //Database codes
        System.out.println("Removed from the database.");
    }
    @Override
    public void update(Student item) {
        //Database codes
        System.out.println("Added to the database.");
    }
    @Override
    public Student get(int id) {
        //Database codes
        ArrayList<String> testCourses = new ArrayList<String>();
        testCourses.add("Calculus");
        return new Student("Example Student", id, testCourses);
    }
}
```
  ```java
import java.util.ArrayList;

public class Student {
    private String name;
    private int id;
    ArrayList<String> courses;

    public Student(String name, int id, ArrayList<String> courses){
        this.name = name;
        this.id = id;
        this.courses = courses;
    }

    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }
}
```
```java
public class Validator {
    public static <T> void validate(T item){
        System.out.println("Data is valid.");
    }
}
```
        
Her bir i≈ülemin altƒ±nda √ßalƒ±≈üan i≈ülem par√ßacƒ±klarƒ±na thread adƒ± verilir. Thread‚Äôler bir ana i≈ülemin i√ßerisinde √ßalƒ±≈üan ve processlere (i≈ülem) g√∂re daha az kaynak t√ºketerek asenkron olarak √ßalƒ±≈üan yapƒ±lardƒ±r. Multithreading, i≈ülemcinin daha efektif bir bi√ßimde kullanƒ±labilmesi i√ßin bir programƒ±n farklƒ± i≈ülemlerinin ayrƒ± ayrƒ± i≈ülem par√ßacƒ±klarƒ±nda yapƒ±lmasƒ±dƒ±r. Normalde i≈ülemler sƒ±rasƒ±yla art arda ger√ßekle≈ütirilirken bu yapƒ± sayesinde i≈ülemler birbirlerini beklemeden kendi i≈ülemini yapar. Java‚Äôda kodumuzun aynƒ± anda birden fazla i≈ülem yapmasƒ±nƒ± istediƒüimizde zaman Thread‚Äôleri kullanmamƒ±z gerekmektedir.

Java‚Äôda thread‚Äôleri kullanmanƒ±n iki yolu vardƒ±r: 
  
‚Ä¢	Thread sƒ±nƒ±fƒ±ndan kalƒ±tƒ±m alan bir alt sƒ±nƒ±f yaratƒ±p, onun run() fonksiyonu override edilir, ardƒ±ndan start() metodu ile bu sƒ±nƒ±f √ßaƒürƒ±lƒ±r.
  
‚Ä¢	Runnable interface‚Äôinden kalƒ±tƒ±m alan bir alt sƒ±nƒ±f yaratƒ±lƒ±r ve run() fonksiyonunu override edilir ardƒ±ndan start() metodu ile bu sƒ±nƒ±f √ßaƒürƒ±lƒ±r.

Java‚Äôda bir i≈ü par√ßacƒ±ƒüƒ±nƒ± belli bir s√ºre bekletmek istersek, Thread sƒ±nƒ±fƒ±na ait sleep() fonksiyonunu kullanabiliriz. Ancak bu y√∂ntem senkronizasyonu saƒülarken thread yapƒ±sƒ±nƒ±n saƒüladƒ±ƒüƒ± avantajƒ± ortadan kaldƒ±rƒ±r. sleep() fonksiyonu milisaniye cinsinden bir deƒüer alƒ±r. Yani 1000 deƒüeri girildiƒüinde 1 saniyeye kar≈üƒ±lƒ±k gelmektedir. sleep() fonksiyonu hata fƒ±rlatabilen bir fonksiyon olduƒüundan try-catch bloƒüu i√ßinde kontrol edilmelidir

Thread sƒ±nƒ±fƒ±nƒ± extend ederek kullanma y√∂ntemi genellikle tercih edilen bir y√∂ntem deƒüildir. √á√ºnk√º yazƒ±lƒ±mƒ±mƒ±zdaki i≈ü akƒ±≈üƒ± i√ßerisinde sƒ±nƒ±fƒ±mƒ±zƒ±n katƒ±lƒ±m geli≈üimini engellemi≈ü oluyoruz. √á√ºnk√º Java‚Äôda bir sƒ±nƒ±f birden fazla sƒ±nƒ±ftan miras alamaz. Bu sebeple Runnable‚Äôƒ± implement ederek kullanmayƒ± tercih etmek daha doƒüru olacaktƒ±r denebilir.

√ñƒürendiklerimden sonra √∂rnekler yapmaya ba≈üladƒ±m. A≈üaƒüƒ±daki √∂rnekte 5‚Äôe kadar senkronize olarak sayan 2 kronometre olu≈üturdum. sleep() fonksiyonunu kullanarak ger√ßek bir kronometre gibi saniye bazlƒ± olarak saymasƒ±nƒ± saƒüladƒ±m.
```java
public class ChronometerThread implements Runnable{
    private Thread thread;
    private String threadName;

    ChronometerThread(String threadName){
        this.threadName = threadName;
        System.out.println("Creating a thread: " + threadName);
    }

    @Override
    public void run() {
        try{
            for(int i = 0; i <= 5; i++){
                System.out.println(threadName + ": " + i);
                Thread.sleep(1000);
            }
        }catch(InterruptedException exception){
            System.out.println("Error!");
        }

        System.out.println("Thread " + threadName + " is over.");
    }

    public void start(){
        System.out.println("Creating a thread object");
        if(thread == null){
            thread = new Thread(this, threadName);
            thread.start();
        }
    }
}
```
                                 

## üìî Java 12. G√ºn
### MySQL kurulumu, temel SQL sorgularƒ± ve Java‚Äôda JDBC ile database (veri tabanƒ±) baƒülantƒ±sƒ±
SQL, ili≈ükisel bir veri tabanƒ±ndaki verilerin alƒ±nmasƒ± ve y√∂netimi i√ßin tasarlanmƒ±≈ü bir veri tabanƒ± dilidir. SQL, Yapƒ±landƒ±rƒ±lmƒ±≈ü Sorgu Dili anlamƒ±na gelir. Komutlar genelde b√ºy√ºk harfle yazƒ±lsa da SQL dili case sensitive bir dil deƒüildir yani b√ºy√ºk harf - k√º√ß√ºk harf duyarlƒ±lƒ±ƒüƒ± yoktur. T√ºm SQL komutlarƒ± SELECT, WHERE, INSERT, UPDATE, DELETE, ALTER, DROP, CREATE gibi anahtar kelimelerin herhangi biriyle ba≈ülar ve noktalƒ± virg√ºl ile (;) biter.

MySQL‚Äôin kurulumla beraber gelen, √ºlke ve ≈üehirleri i√ßeren world verisi ile komutlarƒ± √∂ƒürendik√ße √∂rnek uygulamalarƒ±nƒ± yaptƒ±m.

**SELECT** en √ßok kullanƒ±lan SQL komutudur ve veri tabanƒ±ndan belirtilen s√ºtunlardaki verileri √ßekmemizi saƒülar. SELECT komutunu √ßoƒüunlukla diƒüer SQL komutlarƒ±yla birlikte kullanƒ±rƒ±z. Eƒüer tablodaki t√ºm s√ºtunlardaki verileri √ßekmek istersek Java paketlerinde olduƒüu gibi * karakterini kullanƒ±rƒ±z.

```sql
select * from country;
```
```sql
select Name,Continent,Region from country;
```

**WHERE** komutu, yalnƒ±zca belirtilen bir ko≈üulu yerine getiren kayƒ±tlarƒ± ayƒ±klamak i√ßin kullanƒ±lƒ±r.
```sql
SELECT * from country WHERE Continent = 'Europe' AND Population > 50000000;
```

**INSERT INTO** komutu, tabloya yeni kayƒ±tlar eklemek i√ßin kullanƒ±lƒ±r.
```sql
INSERT INTO city (Name, CountryCode, District, Population) values('D√ºzce','TUR','D√ºzce',1000);
```
  
**UPDATE** komutu, bir tablodaki var olan kayƒ±tlarƒ± deƒüi≈ütirmek, g√ºncellemek amacƒ±yla kullanƒ±lƒ±r. Ancak ≈üart belirtilmediƒüinde g√ºncellemeden tablodaki t√ºm kayƒ±tlar etkilenecektir.
```sql
UPDATE city set Population = 500000 WHERE Name = 'D√ºzce';
```
  
**DELETE** komutu, veri tabanƒ±ndan kayƒ±t ya da kayƒ±tlarƒ± silmek i√ßin kullanƒ±lƒ±r. Ancak ≈üart belirtilmediƒüinde tablodaki t√ºm kayƒ±tlar silinir.
```sql
delete from city where id = 4084;
```
         
JDBC, Java diliyle veri tabanlarƒ±na baƒülanƒ±p sorgu (query) √ßalƒ±≈ütƒ±rmak, veri tabanƒ± ile etkile≈üimli uygulamalar geli≈ütirmek i√ßin ortaya √ßƒ±kmƒ±≈ü bir k√ºt√ºphanedir. JDK i√ßinde varsayƒ±lan olarak hazƒ±r kullanƒ±labilir ≈üekilde gelmektedir. JDBC API her veri tabanƒ± y√∂netim sistemi i√ßin yazƒ±lmƒ±≈ü olan s√ºr√ºc√º k√ºt√ºphanelerini kullanarak veri tabanƒ± i≈ülemlerini yapabilmeyi saƒülar. Java ve veri tabanƒ± arasƒ±nda k√∂pr√º g√∂revi g√∂r√ºr.

JDBC, Java ile veri tabanƒ± ile etkile≈üimde olan kodlarƒ± yazdƒ±ƒüƒ±mƒ±zda, s√ºr√ºc√º k√ºt√ºphane √∂rneƒüin MySQL‚Äôden Oracle veri tabanƒ± sistemine ge√ßse bile hi√ßbir deƒüi≈üiklik gerektirmeden kullanƒ±mƒ±nƒ± saƒülar. B√∂ylece, Java ile veri tabanƒ±yla i≈ülemler yapabilmek i√ßin yazdƒ±ƒüƒ±nƒ±z kodlarƒ± deƒüi≈ütirmeden istediƒüimiz veri tabanƒ± sistemiyle √ßalƒ±≈üabiliriz. B√∂ylece Java kodlarƒ±nƒ±n yeniden kullanƒ±labilirliƒüini artmaktadƒ±r. JDBC API ile veri tabanƒ± baƒülantƒ±sƒ± olu≈üturup, tablolar √ºzerinde sorgu √ßalƒ±≈ütƒ±rabiliyoruz. Sorgulama, veri g√ºncelleme, silme veya yeni kayƒ±t ekleme i≈ülemlerini yapabiliyoruz.

JDBC API veritabanƒ± i≈ülemleri i√ßin gerekli olan abstractionƒ± saƒülar, daha sonra kendisine verilen driver ile sorgularƒ± ilgili veritabanƒ±na iletir, sorgunun √ßalƒ±≈ütƒ±rƒ±lmasƒ± sonucunda √ºretilen √ßƒ±ktƒ±yƒ± da java uygulamasƒ±na geri iletir. Burada √∂nemli olan hangi veritabanƒ±na baƒülanƒ±lacaksa ona uygun driver kullanƒ±lmasƒ±dƒ±r. JDBC ile veri tabanƒ± baƒülantƒ±sƒ± kurabilmek i√ßin √∂ncelikle Intellij IDEA √ºzerinden MySQL ile birlikte gelen mysql-connector-java k√ºt√ºphanesini bu konu i√ßin olu≈üturduƒüum projeme ekledim.
		
DriverManager sƒ±nƒ±fƒ±nda bulunan static `getConnection()` metodu, kendisine verdiƒüimiz parametreleri kullanarak uygulamamƒ±z ve veri tabanƒ± arasƒ±nda bir baƒülantƒ± kurulmasƒ±nƒ± saƒülar. Bu metot √º√ß tane String parametre alƒ±r. ƒ∞lki veri tabanƒ±nƒ±n url‚Äôsi, ikincisi kullanƒ±cƒ± adƒ± ve √º√ß√ºnc√ºs√º ise kullanƒ±cƒ± ≈üifresidir. `getConnection()` metodu geri d√∂n√º≈ü olarak Connection aray√ºz√ºn√º uygulayan bir sƒ±nƒ±f d√∂nd√ºr√ºr.

Baƒülantƒ± kurulduktan sonra JDBC API ile artƒ±k sorgu √ßalƒ±≈ütƒ±rabiliriz. Veri tabanƒ±na SQL ifadesi g√∂ndermek i√ßin Statement aray√ºz√ºnden t√ºretilen objeler yaratmamƒ±z gerekir. `getConnection()` metodu vasƒ±tasƒ±yla olu≈üturduƒüumuz Connection t√ºr√ºndeki nesne, veri tabanƒ± sunucusuyla uygulamamƒ±z arasƒ±ndaki baƒülantƒ± nesnesidir. Bu nesne √ºzerinden `createStatement()` fonksiyonu ile sorgu hazƒ±rlayabileceƒüimiz Statement tipinde bir nesne alƒ±rƒ±z. Statik veriler kullanƒ±rken SQL sorgularƒ±mƒ±zƒ± bu nesne tipi √ºzerinden yaparƒ±z. Bu nesnenin `executeQuery()` metodu SELECT sorgularƒ±nƒ± √ßalƒ±≈ütƒ±rmak i√ßin kullanƒ±lƒ±r, parametre olarak String tipinde select sorgusunu alƒ±r ve elde edilen sonu√ßlar ResultSet objesi olarak geri d√∂ner. Tabloda veya veri tabanƒ±nda yapƒ±sal deƒüi≈üikliƒüe yol a√ßan INSERT, UPDATE, DELETE, CREATE, ALTER, DROP gibi komutlar ise bu nesnenin `executeUpdate()` metodu ile kullanƒ±labilir. Bu metod INSERT, UPDATE ve DELETE komutlarƒ± ile √ßalƒ±≈ütƒ±rƒ±ldƒ±ƒüƒ± zaman bu komuttan etkilenen kayƒ±t sayƒ±nƒ± d√∂nd√ºr√ºr. CREATE, ALTER, DROP komutlarƒ± ile √ßalƒ±≈ütƒ±rƒ±ldƒ±ƒüƒ± zaman ise sƒ±fƒ±r deƒüeri d√∂nd√ºr√ºr. 

Veri √ßekme i≈ülemi sonrasƒ±nda veri listelemek i√ßin kullanƒ±lan ResultSet sƒ±nƒ±fƒ± veriler √ºzerinde dola≈ümak i√ßin `next()`, `first()`, `last()`, `previous()`, `absolute()` gibi metotlara sahiptir. `next()` fonksiyonu: bu fonksiyon √ßaƒürƒ±ldƒ±ƒüƒ±nda bir sonraki satƒ±ra ilerler. B√∂ylece o satƒ±r √ºzerinde okuma yapabilmeyi saƒülar. Okunacak kayƒ±t kalmadƒ±ƒüƒ±nda ‚Äúfalse‚Äù d√∂ner. `first()` fonksiyonu √ßaƒürƒ±ldƒ±ƒüƒ±nda sorgu sonucu k√ºmesindeki ilk elemana eri≈üim saƒülar. `last()` fonksiyonu √ßaƒürƒ±ldƒ±ƒüƒ±nda sorgu sonucu k√ºmesindeki son elemana eri≈üim saƒülar. `absolute()` fonksiyonu ile sorgu sonu√ß k√ºmesindeki direkt olarak istenilen eleman i≈üaret edilir. Veritabanƒ± s√ºtunlarƒ±nda yer alan verileri almak i√ßin ise `getString()`, `getInt()` gibi metotlar kullanƒ±lƒ±r.

Ayrƒ±ca SQLException sƒ±nƒ±fƒ±, bir veri tabanƒ± baƒülantƒ±sƒ± ve uygulamalarƒ±nda meydana gelen hatalarƒ± y√∂netir. JDBC kullanƒ±rken kullanƒ±lan metotlar SQLException exception‚Äôlarƒ± √ºrettiƒüi i√ßin bu metotlar try-catch bloklarƒ± i√ßinde kullanƒ±lmalƒ±dƒ±r. Ayrƒ±ca son olarak kullandƒ±ƒüƒ±mƒ±z Connection, Statement, ResultSet vb. t√ºrlerindeki nesnelerin baƒülantƒ±sƒ±nƒ± `close()` metodu ile kapatmalƒ±yƒ±z.
  
```java
import java.sql.*;

public class Main {
    public static void main(String[] args) throws SQLException{
        Connection dbConnection = null;
        Statement statement = null;
        ResultSet resultSet;
        DbHelper helper = new DbHelper();
        try{
            dbConnection = helper.getConnection();
            statement = dbConnection.createStatement();
            resultSet = statement.executeQuery("SELECT Code, Name, Continent, Region from country");
            int count = 0;
            while(resultSet.next()){
                System.out.println(resultSet.getString("Name") + " " + resultSet.getString("Code"));
                count++;
            }
            System.out.println("-- " + count + " countries printed --");
        }
        catch(SQLException exception){
            helper.showErrorMessage(exception);
        }
        finally {
            dbConnection.close();
        }
    }
}
```
  
## üìî Java 13. G√ºn
### Java‚Äôda JDBC ile veri tabanƒ± i≈ülemleri (SELECT, INSERT, UPDATE, DELETE) ve verileri nesnelere aktarma
Veri tabanƒ± baƒülantƒ±sƒ± kurduƒüum main metodunun bazƒ± kƒ±sƒ±mlarƒ±nƒ± DbHelper adlƒ± ba≈üka bir class‚Äôa ta≈üƒ±dƒ±m. 
```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DbHelper {
    private String userName = "root";
    private String password = "12345";
    private String dbUrl = "jdbc:mysql://localhost:3306/world";

    public Connection getConnection() throws SQLException {
        return DriverManager.getConnection(dbUrl, userName, password);
    }

    public void showErrorMessage(SQLException exception){
        System.out.println("Error: " + exception.getMessage());
        System.out.println("Error Code: " + exception.getErrorCode());
    }
}
```
Sonrasƒ±nda SELECT sorgusu ile Java √ºzerinden world database‚Äôindeki t√ºm √ºlkelerin isimlerini, kodlarƒ±nƒ±, kƒ±talarƒ±nƒ± ve b√∂lgelerinin verisini √ßektim. Ardƒ±ndan bu √ºlkelerin isim ve kodlarƒ±nƒ± ekrana bastƒ±rdƒ±m.
```java
import java.sql.*;

public class Main {
    public static void main(String[] args) throws SQLException{
        Connection dbConnection = null;
        Statement statement = null;
        ResultSet resultSet;
        DbHelper helper = new DbHelper();
        try{
            dbConnection = helper.getConnection();
            statement = dbConnection.createStatement();
            resultSet = statement.executeQuery("SELECT Code, Name, Continent, Region from country");
            int count = 0;
            while(resultSet.next()){
                System.out.println(resultSet.getString("Name") + " " + resultSet.getString("Code"));
                count++;
            }
            System.out.println("-- " + count + " countries printed --");
        }
        catch(SQLException exception){
            helper.showErrorMessage(exception);
        }
        finally {
            dbConnection.close();
        }
    }
}
```
Ardƒ±ndan verileri nesnelere aktarmak i√ßin bir Country sƒ±nƒ±fƒ± olu≈üturdum. Main metodunda deƒüi≈üiklikler yaparak veri tabanƒ±ndaki √ºlkelerin isim, kod, kƒ±ta ve b√∂lge verileriyle bir ArrayList‚Äôe Country nesnesi olarak ekledim.
```java
public class Country {
    private String code;
    private String name;
    private String continent;
    private String region;

    public Country(String code, String name, String continent, String region){
        this.code = code;
        this.name = name;
        this.continent = continent;
        this.region = region;
    }
}
```
```java
import java.sql.*;
import java.util.ArrayList;
  
public class Main {
    public static void main(String[] args) throws SQLException{
        DbHelper helper = new DbHelper();
        Connection dbConnection = null;
        Statement statement = null;
        ResultSet resultSet;
        ArrayList<Country> countries = new ArrayList<Country>();
        try{
            dbConnection = helper.getConnection();
            statement = dbConnection.createStatement();
            resultSet = statement.executeQuery("SELECT Code, Name, Continent, Region from country");
            while(resultSet.next()){
                countries.add(new Country(resultSet.getString("Code"), resultSet.getString("Name"), resultSet.getString("Continent"), resultSet.getString("Region")));
            }
            System.out.println(countries.size() + " countries added to the ArrayList.");
        }
        catch(SQLException exception){
            helper.showErrorMessage(exception);
        }
        finally {
            dbConnection.close();
        }
    }
}
```
Ardƒ±ndan, √∂nceki kodumun try bloƒüunu deƒüi≈ütirerek D√ºzce ≈üehrini world veri tabanƒ±nƒ±n city tablosuna Java √ºzerinden insert ettim.
```java
try{
    dbConnection = helper.getConnection();
    statement = dbConnection.createStatement();
    statement.executeUpdate("INSERT INTO city(Name, CountryCode, District, Population) values('D√ºzce','TUR','D√ºzce','500000')");
    System.out.println("Added to database.");
}
```
         
PreparedStatement interface‚Äôi verilerin dinamik olarak g√∂nderilebildiƒüi parametrik SQL sorgularƒ±nda kullanƒ±lƒ±r. √ñnce sorgu bu nesnenin `prepareStatement()` metodu ile i≈ülenir. Sonrasƒ±nda `setString()`, `setInt()` gibi, SQL sorgularƒ±nda yer alan alanlara deƒüer atamaya yarayan, metotlarla parametre sƒ±rasƒ± ve veri girilir. Bu metotlar sorgu string‚Äôine yazƒ±lan ? simgelerinin yerlerine verilen sƒ±rayla deƒüer atarlar. Son olarak `executeUpdate()` ve `executeQuery()` gibi metotlar ile sorgu √ßalƒ±≈ütƒ±rƒ±lƒ±r. Statement nesnesinde her sorgu ayrƒ± ayrƒ± derlenip kullanƒ±lƒ±rken, PreparedStatement‚Äôda sorgu bir kere derlenir ve gerekli alanlara parametre ile deƒüer yollanƒ±r. Bu durum programƒ±mƒ±za hƒ±z ve d√º≈ü√ºk kaynak kullanƒ±mƒ± saƒülayabilir. 

PreparedStatement hakkƒ±nda bilgi edindikten sonra √∂ƒürendiklerimi peki≈ütirmek i√ßin √∂rnekler yaptƒ±m. 

A≈üaƒüƒ±daki √∂rnekte bir √∂nceki kodumu PreparedStatement kullanarak olu≈üturdum.
```java
import java.sql.*;
import java.util.ArrayList;
  
public class Main {
    public static void main(String[] args) throws SQLException{
        DbHelper helper = new DbHelper();
        Connection dbConnection = null;
        PreparedStatement statement = null;
        try{
            dbConnection = helper.getConnection();
            statement = dbConnection.prepareStatement(
                    "INSERT INTO city(Name, CountryCode, District, Population) VALUES(?,?,?,?)");
            statement.setString(1,"D√ºzce");
            statement.setString(2,"TUR");
            statement.setString(3,"D√ºzce");
            statement.setInt(4,800000);
            statement.executeUpdate();
            System.out.println("Added to database.");
        }
        catch(SQLException exception){
            helper.showErrorMessage(exception);
        }
        finally {
            dbConnection.close();
            statement.close();;
        }
    }
}
```
Ardƒ±ndan parametreli update i≈ülemi yaparak D√ºzce‚Äônin n√ºfus verisini 400000 olarak g√ºncelledim. Ayrƒ±ca bu sefer MySQL‚Äôden edindiƒüim id bilgisini kullanarak g√ºncelleme yaptƒ±m.
```java
import java.sql.*;
import java.util.ArrayList;
  
public class Main {
    public static void main(String[] args) throws SQLException{
        DbHelper helper = new DbHelper();
        Connection dbConnection = null;
        PreparedStatement statement = null;
        try{
            dbConnection = helper.getConnection();
            statement = dbConnection.prepareStatement("UPDATE city set Population = ? WHERE id = ?");
            statement.setInt(1,400000);
            statement.setInt(2,4087);
            statement.executeUpdate();
            System.out.println("Updated successfully.");
        }
        catch(SQLException exception){
            helper.showErrorMessage(exception);
        }
        finally {
            dbConnection.close();
            statement.close();;
        }
    }
}
```
Ardƒ±ndan DELETE sorgusu ile city tablosundan yine id‚Äôsini kullanarak D√ºzce‚Äôyi sildim.
```java
try{
    dbConnection = helper.getConnection();
    statement = dbConnection.prepareStatement("DELETE from city WHERE id = ?");
    statement.setInt(1, 4087);
    statement.executeUpdate();
    System.out.println("Deleted successfully.");
}
```
  
## üìî Java 14. G√ºn
### Java‚Äôda dosyalar ile √ßalƒ±≈ümak
Java.io paketinin File sƒ±nƒ±fƒ±, dosyalar ve dizinler √ºzerinde √ße≈üitli i≈ülemler ger√ßekle≈ütirmek i√ßin kullanƒ±lƒ±r. Bir File nesnesi olu≈üturmak i√ßin, √∂nce java.io.File paketini i√ße aktarmamƒ±z gerekir. Yeni bir File nesnesi olu≈ütururken constructor metodunun i√ßine dosya adƒ±nƒ± veya dosyanƒ±n konumunu gireriz. File sƒ±nƒ±fƒ± createNewFile(), delete(), getName(), canRead(), length() gibi metotlara sahiptir. Yeni bir dosya olu≈üturmak i√ßin createNewFile() metodunu kullanabiliriz. Eƒüer yeni bir dosya olu≈üturulursa metot true, dosya zaten belirtilen konumda mevcutsa false deƒüerini d√∂nd√ºr√ºr. Belirtilen dosyayƒ± veya dizini silmek i√ßin File sƒ±nƒ±fƒ±nƒ±n delete() metodunu kullanabiliriz. Ancak, sadece bo≈ü dizinleri silebiliriz. Java File sƒ±nƒ±fƒ±, yeni bir dizin olu≈üturmak i√ßin mkdir() metodunu saƒülar. Metot geriye yeni dizin olu≈üturulursa true, dizin zaten mevcutsa false deƒüerini d√∂nd√ºr√ºr. list() metodu ise belirtilen dizindeki dosya ve dizin adlarƒ±nƒ± bir string array i√ßerisinde d√∂nd√ºr√ºr.

Dosyalarƒ± okumak i√ßin BufferedReader veya daha √∂nce input alƒ±rken kullandƒ±ƒüƒ±m Scanner gibi sƒ±nƒ±flarƒ± kullanabiliyoruz. Scanner metoduyla dosya okumak i√ßin bir Scanner nesnesi olu≈ütururken constructor metodunun i√ßerisine ‚Äúfile‚Äù yazƒ±lƒ±r. Ardƒ±ndan nextLine() metodu ile bulunulan satƒ±r okunur. hasNext() metodu ise bulunulan satƒ±rdan sonra ba≈üka bir satƒ±r bulunuyorsa true deƒüeri d√∂nd√ºr√ºr. B√∂ylece loop kullanarak t√ºm dosyayƒ± okumamƒ±z m√ºmk√ºn olur.

Dosyalara yazmak i√ßin BufferedWriter, FileWriter gibi sƒ±nƒ±flarƒ± kullanabiliyoruz. Bu sƒ±nƒ±flardan nesne olu≈ütururken constructor metodunun i√ßerisine ilk parametre olarak yazƒ±lacak dosya i√ßin olu≈üturulmu≈ü olan File nesnesi yazƒ±lƒ±r. Ardƒ±ndan yazƒ±ma dosyanƒ±n sonundan, mevcut verileri etkilemeyecek ≈üekilde ba≈ülanmak isteniyorsa ikinci parametreye true deƒüeri yazƒ±lƒ±r. Bu deƒüer append deƒüerine kar≈üƒ±lƒ±k gelir. Ayrƒ±ca BufferedReader sƒ±nƒ±fƒ±ndan bir nesne olu≈ütururken constructor metodunun i√ßerisine FileReader sƒ±nƒ±fƒ±ndan bir nesneyi de direkt ge√ßirebiliyoruz

Ek olarak, kullanƒ±lan bu nesneleri verimlilik i√ßin programƒ±n sonunda close() metotlarƒ± ile kapatmamƒ±z gerekir.

A≈üaƒüƒ±daki √∂rnekte FileManager adlƒ± bir sƒ±nƒ±f olu≈üturdum ve i√ßerisinde createFile(), getFileInfo(), readFile(), writeFile() metotlarƒ± olu≈üturdum.
```java
public class FileManager {

    public File createFile(String filePath){
        File file = new File(filePath);
        try {
            if(file.createNewFile()){
                System.out.println("File created.");
            }
            else{
                System.out.println("File already exists.");
            }
        } catch (IOException exception){
            throw new RuntimeException(exception);
        }
        return file;
    }

    public void getFileInfo(File file){
        System.out.println("File name: " + file.getName());
        System.out.println("File path: " + file.getAbsolutePath());
        System.out.println("Is it readable: " + file.canRead());
        System.out.println("Is it writable: " + file.canWrite());
        System.out.println("File size (byte): " + file.length());
    }

    public void readFile(File file){
        try {
            Scanner reader = new Scanner(file);
            while(reader.hasNext()){
                String line = reader.nextLine();
                System.out.println(line);
            }
            reader.close();
        } catch (FileNotFoundException exception) {
            throw new RuntimeException(exception);
        }
    }

    public void writeFile(File file, String stringToWrite){
        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
            writer.write(stringToWrite);
            writer.newLine();
            writer.close();
        } catch (IOException exception) {
            throw new RuntimeException(exception);
        }
    }
}
```

## üìî Java 15. G√ºn
### ƒ∞leri Seviye Java - Spring Framework‚Äôe giri≈ü
Spring, Java i√ßin geli≈ütirilmi≈ü a√ßƒ±k kaynak kodlu bir framework‚Äôt√ºr. Java uygulamalarƒ±nƒ± geli≈ütirmeyi kolayla≈ütƒ±rƒ±r. Spring bir√ßok mod√ºl√º ve √º√ß√ºnc√º parti k√ºt√ºphaneleri kullanƒ±ma sunarak onlarla sƒ±kƒ±ntƒ±sƒ±z bir ≈üekilde entegrasyon i≈ülemi saƒülar. Spring, Core Container, AOP, Data Access, Web gibi mod√ºllerden olu≈üur.

1) Core Container
Spring Core Container d√∂rt mod√ºlden olu≈üur: Core, Beans, Context ve Expression Language. Spring Core, Spring framework√ºn√ºn uygulamalara entegre edilecek temel mekanizmalarƒ± i√ßeren par√ßasƒ±dƒ±r. Core Container i√ßerisindeki Core ve Beans mod√ºlleri Spring Framework‚Äôunun en temel √∂zelliƒüi olan Inversion of Control (IoC) ve Dependency Injection (DI) ‚Äòƒ± saƒülamaktadƒ±r. 

IoC, kontrol√ºn uygulamadan alƒ±narak framework‚Äôe(Spring) aktarƒ±lmasƒ±dƒ±r. IoC ile Java nesnelerinin olu≈üturulmasƒ±, ya≈üam s√ºreleri, nesneler arasƒ± baƒüƒ±mlƒ±lƒ±klar ve t√ºm bunlarƒ±n y√∂netimi yazƒ±lƒ±m geli≈ütiriciden alƒ±nƒ±p Spring‚Äôe verilmi≈ü olur.

DI, baƒüƒ±mlƒ±lƒ±klarƒ± ortadan kaldƒ±rmak ≈üeklinde ifade edilir. Yazƒ±lƒ±m geli≈ütiricilerin uygulamalarƒ±nda ihtiya√ß duyduƒüu nesneleri(beans), diƒüer nesneler ile ili≈ükilendirirken, ili≈üki kurma i≈üini yazƒ±lƒ±m geli≈ütiricinin √ºzerinden almasƒ±dƒ±r.

Varsayƒ±lan olarak Spring, uygulamanƒ±zda tanƒ±mladƒ±ƒüƒ±nƒ±z nesnelerin hi√ßbirini bilmez. Spring'in nesnelerinizi g√∂rmesini saƒülamak i√ßin onlarƒ± context i√ßine eklememiz gerekir. Spring Context'in i√ßine eklenen objeler, context tarafƒ±ndan y√∂netilir, configure edilir ve gerektiƒüinde √ßaƒürƒ±lƒ±r. Bu ≈üekilde, framework‚Äô√ºn sunduƒüu √∂zellikleri kullanmamƒ±za izin verir.

Spring, farklƒ± gereksinimlere uygun farklƒ± ApplicationContext implementasyonlarƒ± sunar. T√ºm bu implementasyonlar, ApplicationContext interfece'inden t√ºremektedir. Bazƒ± yaygƒ±n ApplicationContext t√ºrleri:

‚Ä¢	AnnotationConfigApplicationContext
‚Ä¢	AnnotationConfigWebApplicationContext
‚Ä¢	XmlWebApplicationContext
‚Ä¢	FileSystemXMLApplicationContext
‚Ä¢	ClassPathXmlApplicationContext

2) AOP (Aspect Oriented Programming)
Spring AOP mod√ºl√º, kodu temiz bir ≈üekilde ayƒ±rabilmek i√ßin Java dilinde implemente edilmi≈ü Proxy tabanlƒ± bir √ßatƒ±dƒ±r. AOP ile transaction y√∂ntemi sayesinde log ve g√ºvenlik gibi mod√ºller merkezi bir yerde toplanƒ±r ve lazƒ±m olduƒüunda projeden baƒüƒ±msƒ±z olarak √ßaƒürƒ±labilir.

3-) Data Access
Bu katmanda JDBC, ORM, OXM, JMS ve Transaction mod√ºlleri bulunur. Bu mod√ºller database ile etkile≈üim kurmayƒ± saƒülar.

4) Web
Bu katmanda Web, Web-Servlet ve Web-Portlet mod√ºlleri bulunur. Bu mod√ºller web uygulamasƒ± olu≈üturmayƒ± saƒülar.

5) Test
Bu katman JUnit ve TestNG mod√ºlleri ile test i≈ülemini saƒülar.

Spring framework‚Äôte Core Container mod√ºl√º haricindeki mod√ºlleri kullanmak isteƒüe baƒülƒ±dƒ±r. Hi√ß kullanƒ±lmayabilir ya da arzu edilen ve benzer fonksiyonu yerine getiren diƒüer teknolojiler kullanƒ±labilir.

Spring framework ve mod√ºlleri hakkƒ±nda genel bilgiler edindikten sonra Spring‚Äôi y√∂netmeye yarayan ApplicationContext‚Äôler hakkƒ±nda daha detaylƒ± bilgiler edinmeye ba≈üladƒ±m.

AnnotationConfigApplicationContext class‚Äôƒ± Spring 3.0 ile birlikte ekosisteme dahil oldu. G√ºncel olarak en yaygƒ±n kullanƒ±lan Application Context olu≈üturma metodu budur.
Input olarak @Configuration veya @Component ile annotate edilmi≈ü sƒ±nƒ±flarƒ± alƒ±r.

Bean, Spring context i√ßine eklediƒüimiz object instance'larƒ±nƒ±n her birine verilen isimdir. Kƒ±saca, context i√ßinde yer alan her bir nesne bean olarak adlandƒ±rƒ±lƒ±r. Spring context'e bean eklemenin birden fazla yolu vardƒ±r. Bu y√∂ntemleri ≈üu ≈üekilde sƒ±ralayabiliriz:

‚Ä¢	XML konfig√ºrasyonu kullanarak
‚Ä¢	@Bean anotasyonunu kullanarak
‚Ä¢	Stereotype (@Component, @Repository, @Service and @Controller) anotasyonlarƒ±nƒ± kullanarak

@Bean anotasyonunu kullanarak Spring context'e bir bean eklemek i√ßin, projeye Spring context'i yapƒ±landƒ±rmak i√ßin kullanacaƒüƒ±mƒ±z ve @Configuration anotasyonu ile i≈üaretlenmi≈ü bir yapƒ±landƒ±rma sƒ±nƒ±fƒ± tanƒ±mlanƒ±r. Ardƒ±ndan Context'e eklemek istediƒüimiz nesneyi d√∂nd√ºren metot yapƒ±landƒ±rma sƒ±nƒ±fƒ±na eklenir ve @Bean anotasyonuyla bu metot i≈üaretlenir.

Stereotype (@Component, @Repository, @Service and @Controller) anotasyonlarƒ±nƒ± kullanarak da bean'lerimizi context'e ekleyebiliriz. √ñnce @Component anotasyonunu kullanarak, Spring'in kendi context'ine bir instance eklemesini istediƒüimiz sƒ±nƒ±flar i≈üaretlenir. Ardƒ±ndan olu≈üturduƒüumuz konfig√ºrasyon sƒ±nƒ±fƒ± √ºzerinde @ComponentScan anotasyonu kullanƒ±larak, Spring'e i≈üaretlediƒüimiz sƒ±nƒ±flarƒ± nerede bulacaƒüƒ± konusunda bilgi verilir.

Ayrƒ±ca bir properties dosyasƒ±ndaki deƒüerleri uygulamamƒ±za aktarmak istersek @Value anotasyonunu kullanabiliyoruz. Bunun i√ßin √∂nce konfig√ºrasyon sƒ±nƒ±fƒ±nda @PropertySource anotasyonu kullanƒ±larak dosyanƒ±n konumu belirtilir. Sonrasƒ±nda, √∂rneƒüin dosyadaki user.name deƒüerini bir deƒüi≈ükene aktarmak istiyorsak @Value(‚Äú${user.name}‚Äù) anotasyonunu kullanƒ±rƒ±z.

Ardƒ±ndan √∂ƒürendiklerimi uyguladƒ±ƒüƒ±m √∂rnekler yaptƒ±m.

## üìî Java 16. G√ºn
### ƒ∞leri Seviye Java - Hibernate
Hibernate, veri tabanƒ±ndaki tablolarla Java‚Äôdaki class‚Äôlarƒ±mƒ±zƒ± e≈üle≈ütirip, class‚Äôlar √ºzerinden veri tabanƒ±ndaki nesneleri map ederek (birbirleriyle ili≈ükilendirerek) verilere hƒ±zlƒ± bir ≈üekilde insert, update, delete ve select operasyonlarƒ± uygulayabilmemizi saƒülar. Hibernate sayesinde JDBC‚Äôye kƒ±yasla daha az kod ile daha hƒ±zlƒ± ≈üekilde veri tabanƒ± baƒülantƒ±sƒ± ve operasyonlarƒ± yapƒ±labilmektedir. Hibernate‚Äônin hangi veritabanƒ±na nasƒ±l i≈üleneceƒüini XML dosyasƒ±nda belirtilir. Hibernate genel anlamda Java veri tiplerinden SQL veri tiplerine d√∂n√º≈ü√ºm√º ger√ßekle≈ütirir ve ayrƒ±ca veri sorgulama ve veri √ßekme i≈ülemlerini de kullanƒ±cƒ± i√ßin saƒülar.

Java sƒ±nƒ±flarƒ±nƒ± veri tabanƒ± nesnesi olarak kullanmak i√ßin @Entity anotasyonunu kullanƒ±rƒ±z. @Table anotasyonu ile de sƒ±nƒ±fƒ±n hangi tablonun nesnesi olarak kullanƒ±lacaƒüƒ±nƒ± belirtiriz. Ardƒ±ndan sƒ±nƒ±fƒ±n niteliklerini, tablonun s√ºtunlarƒ± ile e≈üle≈ütirmek i√ßin @Column anotasyonunu kullanƒ±rƒ±z. 

Hibernate ile veri tabanƒ± i≈ülemleri yapƒ±lƒ±rken SessionFactory ve Session sƒ±nƒ±flarƒ± kullanƒ±lƒ±r. SessionFactory sƒ±nƒ±fƒ±ndan olu≈üturacaƒüƒ±mƒ±z nesne bizim konfig√ºrasyon dosyamƒ±zƒ± okur ve Session objeleri olu≈üturmaya yarar. Ancak SessionFactory aƒüƒ±r bir sƒ±nƒ±f olduƒüu i√ßin uygulama √ßalƒ±≈üƒ±rken yalnƒ±zca bir tane instance olu≈üturulur. Daha sonra t√ºm Session objeleri bu instancedan olu≈üur. Session sƒ±nƒ±fƒ± ise JDBC baƒülantƒ±sƒ±ndan sorumludur, objeleri okumak ve yazmak i√ßin temel sƒ±nƒ±ftƒ±r. SessionFactory sƒ±nƒ±fƒ± tarafƒ±ndan olu≈üturulur. Kƒ±sa s√ºreli ya≈üam d√∂ng√ºs√º vardƒ±r. Gereken i≈ülem yapƒ±ldƒ±ktan sonra session‚Äôƒ± kapatƒ±rƒ±z. 

SessionFactory nesnesi olu≈üturulurken bir Configuration sƒ±nƒ±fƒ± new‚Äôlenir ve ardƒ±ndan configure() metodu ile konfig√ºrasyon dosyasƒ±, addAnnotedClass() metodu ile veri tabanƒ± objesi olarak kullanƒ±lacak class belirtilir. Sonrasƒ±nda ise buildSessionFactory() metodu ile SessionFactory nesnesi olu≈üturulur.

SessionFactory nesnesinin getCurrentSession() metodu ile Session nesnesi olu≈üturulur. Ardƒ±ndan bu nesne ile veri tabanƒ± operasyonlarƒ± ger√ßekle≈ütirilir.

Edindiƒüim bilgilerin ardƒ±ndan Hibernate kullanarak veri tabanƒ± i≈ülemleri yapmaya ba≈üladƒ±m. Veri tabanƒ± olarak daha √∂nce de kullandƒ±ƒüƒ±m world veri tabanƒ±nƒ±n city tablosunu kullandƒ±m. √ñnce Hibernate k√ºt√ºphanesini ve MySQL driver‚Äôƒ±nƒ± projeye ekledim. Ardƒ±ndan City sƒ±nƒ±fƒ± olu≈üturdum ve bu sƒ±nƒ±fƒ± gerekli anotasyonlarƒ± kullanarak veri tabanƒ± nesnesi olarak kullandƒ±m. Sonrasƒ±nda, Hibernate konfig√ºrasyonu i√ßin bir XML dosyasƒ± olu≈üturup konfig√ºreasyonlarƒ± yaptƒ±m. Ardƒ±ndan main metodu i√ßerisinde SessionFactory ve Session nesneleri olu≈üturarak select, insert, update, delete i≈ülemleri yaptƒ±m ve sorunsuz √ßalƒ±≈ütƒ±klarƒ±nƒ± MySQL √ºzerinden doƒüruladƒ±m.

## üìî Java 17. G√ºn
### ƒ∞leri Seviye Java - Maven
Maven, proje geli≈ütirirken proje i√ßerisinde bir standart olu≈üturmamƒ±zƒ±, geli≈ütirme s√ºrecini basitle≈ütirmemizi, dok√ºmantasyonumuzu etkili bir ≈üekilde olu≈üturmamƒ±zƒ±, projemizdeki k√ºt√ºphane baƒüƒ±mlƒ±lƒ±ƒüƒ±nƒ± (dependency) kolayca y√∂netmemizi saƒülayan bir proje kontrol aracƒ±dƒ±r.

√ñrneƒüin normalde el ile ekleyip y√∂netmemiz gereken Hibernate vb. paketleri Maven aracƒ±lƒ±ƒüƒ±yla projemize ekleyip y√∂netebiliyoruz. Maven, k√ºt√ºphane dosyalarƒ±nƒ± kendi repository sunucularƒ±nda barƒ±ndƒ±rƒ±r. Projede kullanmak istediƒüimiz k√ºt√ºphane dosyalarƒ±nƒ± ilk olarak bizim local repository klas√∂r√ºm√ºzde arar, eƒüer bulamazsa kendi sunucularƒ±nda arama yapar, k√ºt√ºphaneyi bizim local klas√∂r√ºm√ºze indirir ve projeniz i√ßerisinde kullanabilmenizi saƒülar. Ayrƒ±ca bir k√ºt√ºphane ba≈üka k√ºt√ºphanelere baƒüƒ±mlƒ±ysa bu baƒüƒ±mlƒ± olduƒüu k√ºt√ºphaneleri de indirir ve projemize ekler.

Maven Repository i√ßerisinde bulunan k√ºt√ºphanelere veya jar‚Äôlara ula≈ümak i√ßin √ße≈üitli adresler vardƒ±r. En √ßok kullanƒ±lanlardan biri https://mvnrepository.com/ sitesidir. Bu site aracƒ±lƒ±ƒüƒ±yla aradƒ±ƒüƒ±mƒ±z paketi kolayca bulup Maven ile projemize ekleyebiliriz.

Maven‚Äôƒ±n bize saƒüladƒ±ƒüƒ± bir diƒüer √∂zellik de versiyon kontrol√ºd√ºr. Maven ile projemizde yer alan k√ºt√ºphanelerin yeni bir s√ºr√ºm√º mevcut olduƒüunda kolayca o s√ºr√ºme ge√ßi≈ü yapabiliriz.

Ayrƒ±ca, Maven bize hazƒ±r proje ≈üablonlarƒ± (archetype) sunar. Bu ≈üablonlar bize standartlar sunar ve biz bu standartlar √ºzerinde projelerimizi geli≈ütiririz.

Maven‚Äôƒ± POM.xml dosyasƒ± ile kontrol ederiz. Project Object Model(POM) dosyasƒ± aslƒ±nda, hem proje hakkƒ±nda bilgileri hemde projenin konfig√ºrasyonu hakkƒ±nda, baƒüƒ±mlƒ±lƒ±klarƒ±, kaynaƒüƒ±, kullanƒ±lan pluginler, projeyi derlemek i√ßin gerekli komutlar vb. bilgileri i√ßeren bir XML dosyasƒ±dƒ±r. POM dosyasƒ±nƒ±n properties b√∂l√ºm√ºnden projenin √∂zelliklerini (Java s√ºr√ºm√º vb.) dependency b√∂l√ºm√ºnden ise projenin k√ºt√ºphane baƒüƒ±mlƒ±lƒ±klarƒ±nƒ± (Hibernate vb.) kontrol ederiz.

Maven hakkƒ±nda bilgi edindikten sonra, Maven‚Äôƒ±n standart bir Java projesi olu≈üturmaya yarayan quickstart archetype‚Äôƒ±nƒ± kullanarak kendi projemi olu≈üturdum. Ardƒ±ndan https://mvnrepository.com/ sitesini kullanarak Hibernate‚Äôi Maven ile projeye ekledim. POM dosyasƒ±nƒ±n dependency b√∂l√ºm√ºne siteden kopyaladƒ±ƒüƒ±m xml satƒ±rlarƒ±nƒ± yapƒ±≈ütƒ±rdƒ±m ve Maven belirtilen s√ºr√ºm√º projeye ekledi. K√ºt√ºphaneleri d√ºn yaptƒ±ƒüƒ±m gibi elle eklemek yerine Maven kullanarak y√ºklemenin ve kontrol etmenin √ßok daha kullanƒ±≈ülƒ± olduƒüunu deneyimledim. Ardƒ±ndan aynƒ± ≈üekilde MySQL connector driver‚Äôƒ±nƒ± da elle eklemek yerine Maven ile ekledim. Ardƒ±ndan d√ºn yazdƒ±ƒüƒ±m Hibernate projesinin Main sƒ±nƒ±fƒ±nƒ± App sƒ±nƒ±fƒ±na aktardƒ±m ve City sƒ±nƒ±fƒ±nƒ± da bu projeye ekledim. D√ºn olu≈üturduƒüum Hibernate konfig√ºrasyon dosyasƒ±nƒ± da bu projeye ekledim. Projemi sorunsuz √ßalƒ±≈ütƒ±rabildim.

## üìî Java 18. G√ºn
### ƒ∞leri Seviye Java - Spring Boot
Stajdaki 19. g√ºn√ºme Spring Boot hakkƒ±nda bilgi edinerek ba≈üladƒ±m. Spring Boot, Spring framework ile geli≈ütirilen, g√º√ßl√º varsayƒ±lan/otomatik ayarlarƒ± sayesinde kolay ve hƒ±zlƒ± Spring tabanlƒ± uygulama yapƒ±mƒ± i√ßin geli≈ütirilmi≈ü bir Spring mod√ºld√ºr. Spring Boot, bize bir Maven projesini istediƒüimiz eklentilerle ve konfig√ºrasyonlarla beraber sunuyor, bize sadece gerekli kodlarƒ± yazmak kalƒ±yor. Bize se√ßeceƒüimiz dependency‚Äôlere (baƒüƒ±mlƒ±lƒ±k) g√∂re hazƒ±r bir proje taslaƒüƒ± sunuyor. Spring Boot‚Äôun en √∂nemli √∂zelliklerinden birisi i√ßerisinde g√∂m√ºl√º ≈üekilde Tomcat gibi yayƒ±nlama ortamlarƒ±nƒ± barƒ±ndƒ±rmasƒ±dƒ±r. Yani bizim ayrƒ±ca Tomcat‚Äôa veya diƒüer sunucu i≈ülemlerine ihtiyacƒ±mƒ±z kalmadan, bunlarƒ± Spring Boot i√ßerisinde √ß√∂zebiliyoruz. Spring Boot‚Äôun saƒüladƒ±ƒüƒ± en b√ºy√ºk avantajlardan biri ise bizi herhangi bir XML konfig√ºrasyonuyla uƒüra≈ümak zorunda bƒ±rakmamasƒ±dƒ±r. Kƒ±sacasƒ± Spring Boot bizlere Spring Framework tarafƒ±ndan sunulan ve i≈üimizi olduk√ßa kolayla≈ütƒ±ran bir yapƒ±dƒ±r.

Spring Boot projesi olu≈ütururken genelde Spring Initializr (https://start.spring.io/) kullanƒ±lƒ±r. Spring Initializr, proje olu≈ütururken in≈üa aracƒ±nƒ± (Maven vb.), JVM dilini (Java, Kotlin vb.), Spring Boot s√ºr√ºm√ºn√º, Java s√ºr√ºm√ºn√º, Projede kullanƒ±lacak olan k√ºt√ºphaneleri / baƒüƒ±mlƒ±lƒ±klarƒ± dinamik olarak belirlemeyi saƒülar. IntelliJ IDEA‚Äôda Spring Initializr bulunduƒüu i√ßin direkt olarak ide‚Äônin i√ßinden proje olu≈üturulabiliyor. (Edit√∂rler Spring Boot projesini √ºretirken Spring Initializr sayfasƒ±nƒ± (https://start.spring.io/) kullanƒ±r.)

Spring Boot projesi olu≈ütururken, Dependencies b√∂l√ºm√º altƒ±nda projenin ≈üablonunu belirtiyoruz. √ñrneƒüin bir web projesi olu≈üturmak istediƒüimizde Spring Web paketini se√ßiyoruz. Burada arama yaparak ihtiyacƒ±mƒ±za g√∂re istediƒüimiz paketleri kullanabiliyoruz.

Spring Boot hakkƒ±nda bilgi edindikten sonra, Spring Boot ile bir Web uygulamasƒ± olu≈üturmak i√ßin REST Api hakkƒ±nda bilgi edinmeye ba≈üladƒ±m. REST, client - server (istemci ‚Äì sunucu) arasƒ±ndaki haberle≈ümeyi saƒülayan, HTTP protokol√º √ºzerinden √ßalƒ±≈üan bir mimaridir. ƒ∞stemci ve sunucu arasƒ±nda XML/JSON verilerini ta≈üƒ±yarak uygulamanƒ±n haberle≈ümesini saƒülar. REST mimarisini kullanan servislere ise RESTful servis (RESTful API) denir.
 REST ile yazƒ±lmƒ±≈ü bir servisle √ßalƒ±≈ümak i√ßin ihtiyacƒ±mƒ±z olan tek ≈üey URL‚Äôdir. Bir URL‚Äôe istek attƒ±ƒüƒ±mƒ±zda, URL bize JSON veya XML formatƒ±nda bir cevap d√∂nd√ºr√ºr, d√∂nen cevap parse edilir ve servis entegrasyonu tamamlanƒ±r. REST servisler; client ve server arasƒ±ndaki ayrƒ±m sayesinde, REST protokol√º, bir projenin farklƒ± alanlarƒ±ndaki geli≈ütirmelerin baƒüƒ±msƒ±z olarak ger√ßekle≈ümesini kolayla≈ütƒ±rƒ±r.

Spring Boot ile Rest Api yazarken @RestController anotasyonunu kullanmamƒ±z gerekir. Yazdƒ±ƒüƒ±mƒ±z servisler i√ßin √ße≈üitli HTTP istek (request) tipleri mevcuttur (GET, POST, PUT vb.). 

‚Ä¢	@GetMapping anotasyonu, GET isteƒüi i√ßin kullanƒ±lƒ±r. ƒ∞√ßine parametre olarak string tipinde url girilir.	
‚Ä¢	@PostMapping anotasyonu, POST isteƒüi i√ßin kullanƒ±lƒ±r. ƒ∞√ßine parametre olarak string tipinde url girilir.

Bu anotasyonlara parametre olarak ‚Äú/‚Äù girilir ise, uygulama √ßalƒ±≈ütƒ±ƒüƒ±nda uygulama sunucumuzun ana sayfasƒ±nda bu anotasyonla tanƒ±mladƒ±ƒüƒ±mƒ±z metot √ßalƒ±≈üƒ±r.

Eƒüer @GetMapping anotasyonunda url kƒ±smƒ±na parametre yollamak istiyorsak { ve } sembollerinin arasƒ±na parametrenin adƒ±nƒ± yazarƒ±z. Ardƒ±ndan ilgili metoda @PathVariable anotasyonu ile bir parametre tanƒ±mlayarak bu iki deƒüi≈ükeni e≈üle≈ütiririz. Ancak bu iki parametrenin adƒ±nƒ±n aynƒ± olmasƒ± gerekir.

Ayrƒ±ca, @RequestMapping anotasyonu sƒ±nƒ±f √ºzerinde kullanƒ±ldƒ±ƒüƒ± zaman, o sƒ±nƒ±fƒ±n belirtilen url ile ilgili t√ºm i≈üleri yapmasƒ± saƒülanƒ±r. Api‚Äôlar genellikle standart olarak domain isminden sonra /api ≈üeklinde url‚Äôlere sahip olurlar. REST Api olarak kullanacaƒüƒ±mƒ±z sƒ±nƒ±fa @RequestMapping(‚Äú/api‚Äù) anotasyonunu eklediƒüimizde, bu sƒ±nƒ±f i√ßinde tanƒ±mlanan request metotlarƒ±nƒ± kullanabilmek i√ßin url‚Äôlerinin ba≈üƒ±na /api yazmamƒ±z gerekir. Bu ≈üekilde uygulamamƒ±z daha d√ºzenli olur.

Ek olarak, Spring Boot ile uygulama geli≈ütirirken her deƒüi≈üiklikte, deƒüi≈üikliƒüin √ßƒ±ktƒ±lara yansƒ±masƒ± i√ßin kodun tekrar derlenmesi; yani bizim uygulamamƒ±zƒ± tekrar √ßalƒ±≈ütƒ±rmamƒ±z gerekir. Zaman kazanmak adƒ±na burada Spring Boot Dev Tools devreye giriyor. Dev Tools dependency‚Äôsini (baƒüƒ±mlƒ±lƒ±k) projeye eklediƒüimizde, her kaydetme i≈üleminde otomatik olarak kodu tekrar derliyor ve √ßƒ±ktƒ±larƒ±mƒ±zƒ± g√ºncelliyor. B√∂ylece uygulamayƒ± tekrar ba≈ülatmamƒ±za gerek kalmƒ±yor.

√ñƒürendiƒüim bilgiler sonrasƒ± ilk Spring Boot Web projemi olu≈üturdum ve √∂rneklerle √∂ƒürendiklerimi uyguladƒ±m.

## üìî Java 19. G√ºn
### ƒ∞leri Seviye Java - Spring Boot
Temel katmanlƒ± mimariler Data Access(DAL), Business, Service ve User Interface(UI) katmanlarƒ±ndan olu≈üur. 

En alt katmanƒ±mƒ±z Data Access(DAL, DAO) katmanƒ±dƒ±r. Data Access katmanƒ± bizim veri eri≈üim katmanƒ±mƒ±zdƒ±r. √ñrneƒüin, temel JDBC, Hibernate vb. kodlarƒ±mƒ±zƒ± bu katmanda yazarƒ±z. 

Business katmanƒ±, bizim i≈ü katmanƒ±mƒ±zdƒ±r. ƒ∞≈ü kurallarƒ± buraya yazƒ±lƒ±r. Belirlenen algoritmalara g√∂re verilerin ≈üekillenmesini saƒülayan logic dediƒüimiz i≈ülemlerin yapƒ±ldƒ±ƒüƒ± katmandƒ±r. √ñrnek olarak veri tabanƒ±ndan belirli bir kurala g√∂re verileri √ßekmek istiyorsak, o kuralƒ± bu i≈ü katmanƒ± i√ßerisinde uygulayarak istediƒüimiz veriyi elde etmi≈ü oluruz.

Service katmanƒ±, RESTful servisler gibi servislerin kodlarƒ±nƒ±n yazƒ±ldƒ±ƒüƒ± katmandƒ±r. Bazƒ± geli≈ütiriciler bu katmanƒ± Business katmanƒ±yla i√ß i√ße yazƒ±yor olsa da ayrƒ± olmasƒ± daha saƒülƒ±klƒ± olacaktƒ±r.

User Interface(UI) katmanƒ±, bizim kullanƒ±cƒ± aray√ºz√º katmanƒ±mƒ±zdƒ±r. Uygulamamƒ±zƒ±n front-end kƒ±smƒ± aray√ºz katmanƒ±nda bulunur. Bu katmanda kullanƒ±cƒ±lara bir ara y√ºz sunulur ve kullanƒ±cƒ±lar bu ara y√ºz ile beraber olu≈üturmu≈ü olduƒüumuz proje ile etkile≈üime ge√ßer.

Bu katmanlar birbirleriyle interface‚Äôler aracƒ±lƒ±ƒüƒ±yla, yani Polymorphism ile, baƒülantƒ± kurarlar.

Uygulamalarƒ±mƒ±zƒ± bu ≈üekilde katmanlara ayƒ±rmamƒ±z uygulama i√ßindeki baƒüƒ±mlƒ±lƒ±klarƒ± azaltƒ±r ve bize avantaj saƒülar. (SOLID yazƒ±lƒ±mƒ±n Single Responsibility prensibi). √ñrneƒüin Business katmanƒ± ile Data Access katmanƒ±nƒ± beraber yazdƒ±ƒüƒ±mƒ±z bir durumda, Data Access i√ßin Hibernate kullandƒ±ƒüƒ±mƒ±zƒ± varsayalƒ±m. Sonrasƒ±nda Hibernate dƒ±≈üƒ±nda farklƒ± bir teknolojiye ge√ßmek istediƒüimizde bu iki katman i√ß i√ße olduƒüu i√ßin t√ºm kodlarƒ± yeniden yazmamƒ±z gerekebilir. Ancak kodlarƒ±mƒ±zƒ± katmanlara ayƒ±rƒ±rsak, bu durumda sadece gerekli katmanƒ±n (Data Access) kodlarƒ±nƒ± deƒüi≈ütirmemiz gerekir ve bu da bize avantaj saƒülar. 

Katmanlƒ± mimariler hakkƒ±nda bilgi edindikten sonra Spring Boot Projemizin y√∂netimsel ayarlamalarƒ±nƒ± yapmak i√ßin gerekli olan application.properties dosyasƒ± hakkƒ±nda bilgi edinmeye ba≈üladƒ±m. application.properties dosyasƒ±, projemizin t√ºm baƒüƒ±mlƒ±lƒ±klarƒ±nƒ±n, deƒüi≈ütirilebilir property‚Äôlerine deƒüer atamamƒ±za ve sonrasƒ±nda da gerektiƒüinde kolaylƒ±kla deƒüi≈ütirebilmemize olanak saƒülar. √ñrneƒüin kullanacaƒüƒ±mƒ±z veri tabanƒ±nƒ±n baƒülantƒ± metnini, kullanƒ±cƒ± adƒ±, ≈üifre gibi deƒüerlerini bu dosyada saklayƒ±p kullanabiliriz. application.properties dosyasƒ±, varsayƒ±lan olarak projemizde src/main/resources yolunda bulunmaktadƒ±r.

Veri tabanƒ± baƒülantƒ± metni i√ßin spring.datasource.url, kullanƒ±cƒ± adƒ± i√ßin spring.datasource.username, ≈üifresi i√ßin spring.datasource.password parametreleri kullanƒ±lƒ±r.

application.properties dosyasƒ± hakkƒ±nda bilgi sahibi olduktan sonra JPA hakkƒ±nda bilgi edinmeye ba≈üladƒ±m.

JPA (Java Persistence API), Java programlama dilinde Java sƒ±nƒ±flarƒ± ile ili≈ükisel veri tabanƒ± tablolarƒ±nƒ± ili≈ükilendirmek i√ßin ortaya √ßƒ±kmƒ±≈ü bir standarttƒ±r. Burada ama√ß sƒ±nƒ±f deƒüi≈ükenleri ile tablonun kolonlarƒ±nƒ± e≈üle≈ütirmek ve SQL yazmadan nesneler √ºzerinden doƒürudan veri tabanƒ± i≈ülemlerini yapmaktƒ±r. Bu noktada JPA sadece bir standart ortaya koyar ve veri √ºzerinde kendisi bir i≈ülem yapmaz. Bunun i√ßin bu standartlarƒ± implemente eden ayrƒ± bir araca ihtiya√ß vardƒ±r, JPA implementasyonu yapan ba≈ülƒ±ca ara√ßlar olarak Hibernate, TopLink, EclipseLink ve OpenJPA sayƒ±labilir.

JPA spesifikasyonunda obje-tablo ili≈ükisini y√∂netmek i√ßin iki tane ara√ß bulunur; anotasyonlar ve XML konfig√ºrasyon dosyalarƒ±. Bu iki ara√ßtan birini kullanarak JPA i√ßin gerekli olan meta bilgisini olu≈üturabiliriz.

Hibernate kullanƒ±rken, SessionFactory ve Session nesnelerinin y√∂netimini JPA sayesinde daha kolay bir ≈üekilde yapabiliyoruz. Bunun i√ßin EntityManager nesnesi olu≈üturup unwrap() metodu ile Session nesnesi olu≈üturuyoruz. Burada, unwrap() metoduna Session.class ifadesini yazƒ±p, Hibernate i√ßin olan sƒ±nƒ±fƒ± se√ßiyoruz. Hibernate kullanƒ±rken olu≈üturduƒüumuz Session nesnesi ile session a√ßƒ±p kapatma i≈ülemini de JPA bizim i√ßin hallediyor. B√∂ylece JPA sayesinde daha az kod yazarak Hibernate‚Äôi kullanabiliyoruz. Bunun i√ßin bu i≈ülemin ger√ßekle≈üeceƒüi metoda @Transactional anotasyonu eklememiz gerekiyor. 

Ek olarak, Spring‚Äôin JPA i√ßin gerekli baƒülantƒ±larƒ± kurabilmesi i√ßin (Hibernate vb.) bu metotlarda @Autowired anotasyonunu kullanmamƒ±z gerekiyor.

B√∂ylece staj projemi yapabilmek i√ßin hazƒ±r hale geldim. Katmanlƒ± mimariye sahip √∂rnek bir proje yazdƒ±m ve g√ºn√º tamamladƒ±m.

## üìî Java 20. G√ºn
### Staj projesi ‚Äì MySQL‚Äôde proje i√ßin veri tabanƒ± olu≈üturma, Java‚Äôda veri tabanƒ± nesnesi i√ßin sƒ±nƒ±f olu≈üturma
Stajƒ±mƒ±n son haftasƒ±nda staj projeme ba≈üladƒ±m. Projem bir blog sitesinin back-end tarafƒ±nda veri tabanƒ± baƒülantƒ±sƒ±nƒ± kurma, veri ekleme/silme/g√ºncelleme/g√∂r√ºnt√ºleme i≈ülemleri √ºzerine. Kullanƒ±cƒ±larƒ±n kullanƒ±cƒ± adƒ±, ≈üifre ve blog yazƒ±larƒ±nƒ± da ayrƒ± deƒüerler olarak veri tabanƒ±nda saklamam istendi. Ayrƒ±ca, katmanlƒ± mimariye sahip olmasƒ± istendi.

√ñncelikle MySQL √ºzerinden projem i√ßin veri tabanƒ± olu≈üturarak ba≈üladƒ±m. ID, Username, Password ve BlogPost s√ºt√ºnlarƒ±na sahip bir veri tabanƒ± tablosu olu≈üturdum. Username deƒüerini unique(e≈üsiz) olarak tanƒ±mladƒ±m. Username ve Password deƒüerlerini de not null (bo≈ü bƒ±rakƒ±lamaz) olarak tanƒ±mladƒ±m.

Ardƒ±ndan projem i√ßin Web, JPA, Dev Tools ve MySQL Connector dependency‚Äôlerine (baƒüƒ±mlƒ±lƒ±k) sahip bir Spring Boot projesi olu≈üturdum.

Sonrasƒ±nda veri tabanƒ± nesnesi olarak kullanƒ±lacak User sƒ±nƒ±fƒ±nƒ± yazdƒ±m.
```java
package com.kafein.project.Entities;

import javax.persistence.*;

@Entity
@Table(name="user")
public class User {

    @Id
    @Column(name="ID")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int userID;

    @Column(name="Username")
    private String username;

    @Column(name="Password")
    private String password;

    @Column(name="BlogPost")
    private String blogPost;

    public User(int userID, String username, String password, String blogPost) {
        this.userID = userID;
        this.username = username;
        this.password = password;
        this.blogPost = blogPost;
    }

    public User(){

    }

    public int getUserID() {
        return userID;
    }

    public void setUserID(int userID) {
        this.userID = userID;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getBlogPost() {
        return blogPost;
    }

    public void setBlogPost(String blogPost) {
        this.blogPost = blogPost;
    }
}
```

## üìî Java 21. G√ºn
### Staj projesi ‚Äì Projenin Data Access katmanƒ±nƒ±n yazƒ±lmasƒ±, application.properties dosyasƒ±nƒ±n konfig√ºrasyonu
Staj projem √ºzerine √ßalƒ±≈ümaya devam ettim. Data Access katmanƒ± i√ßin IUserDal interface‚Äôini yazdƒ±m. Ardƒ±ndan bu interface‚Äôi implement eden HibernateUserDal sƒ±nƒ±fƒ±nƒ± yazdƒ±m.
```java
package com.kafein.project.DataAccess;

import com.kafein.project.Entities.User;
import org.hibernate.Session;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;
import javax.persistence.EntityManager;
import java.util.List;

@Repository
public class HibernateUserDal implements IUserDal{

    private EntityManager entityManager;

    @Autowired
    public HibernateUserDal(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    @Override
    @Transactional
    public List<User> getAll() {
        Session session = entityManager.unwrap(Session.class);
        List<User> users = session.createQuery("from User", User.class).getResultList();
        return users;
    }

    @Override
    @Transactional
    public void add(User user) {
        Session session = entityManager.unwrap(Session.class);
        session.saveOrUpdate(user);
    }

    @Override
    @Transactional
    public void update(User user) {
        Session session = entityManager.unwrap(Session.class);
        session.saveOrUpdate(user);
    }

    @Override
    @Transactional
    public void delete(User user) {
        Session session = entityManager.unwrap(Session.class);
        User userToDelete = session.get(User.class, user.getUserID());
        session.delete(userToDelete);
    }

    @Override
    @Transactional
    public User getById(int id) {
        Session session = entityManager.unwrap(Session.class);
        User user = session.get(User.class, id);
        return user;
    }
}
```
B√∂ylece Data Access katmanƒ±nƒ± tamamlamƒ±≈ü oldum. JPA ile Hibernate‚Äôi daha pratik bir ≈üekilde yazabildim.

Ardƒ±ndan veri tabanƒ± baƒülantƒ±sƒ± i√ßin application.properties dosyasƒ±nƒ±n konfig√ºrasyonunu yaptƒ±m.

## üìî Java 22. G√ºn
### Staj Projesi ‚Äì Projenin Service katmanƒ± ve REST Api‚Äôƒ±nƒ±n yazƒ±lmasƒ±
Projemin Service katmanƒ± i√ßin IUserService interface‚Äôini yazdƒ±m ve ardƒ±ndan bu interface‚Äôi implement eden UserManager sƒ±nƒ±fƒ±nƒ± yazdƒ±m. Katmanlar arasƒ±ndaki baƒülantƒ±yƒ± interface‚Äôler aracƒ±lƒ±ƒüƒ±yla saƒüladƒ±m; UserManager sƒ±nƒ±fƒ± i√ßin IUserDal tipinde userDal niteliƒüi olu≈üturdum.
```java
package com.kafein.project.Service;

import com.kafein.project.Entities.User;
import com.kafein.project.DataAccess.IUserDal;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

@Service
public class UserManager implements IUserService{

    private IUserDal userDal;

    @Autowired
    public UserManager(IUserDal userDal) {
        this.userDal = userDal;
    }

    @Override
    @Transactional
    public List<User> getAll() {
        return this.userDal.getAll();
    }

    @Override
    @Transactional
    public void add(User user) {
        this.userDal.add(user);
    }

    @Override
    @Transactional
    public void update(User user) {
        this.userDal.update(user);
    }

    @Override
    @Transactional
    public void delete(User user) {
        this.userDal.delete(user);
    }

    @Override
    @Transactional
    public User getById(int id) {
        return this.userDal.getById(id);
    }
}
```
Ardƒ±ndan projem i√ßin bir REST Api yazdƒ±m.
```java
package com.kafein.project.RestApi;

import com.kafein.project.Entities.User;
import com.kafein.project.Service.IUserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api")
public class UserController {

    private IUserService userService;

    @Autowired
    public UserController(IUserService userService) {
        this.userService = userService;
    }

    @GetMapping("/users")
    public List<User> get(){
        return this.userService.getAll();
    }

    @PostMapping("/add")
    public void add(@RequestBody User user){
        this.userService.add(user);
    }

    @PostMapping("/update")
    public void update(@RequestBody User user){
        this.userService.update(user);
    }

    @PostMapping("/delete")
    public void delete(@RequestBody User user){
        this.userService.delete(user);
    }

    @GetMapping("/users/{id}")
    public User getById(@PathVariable int id){
        return this.userService.getById(id);
    }

    @RequestMapping("/users/{id}/blog")
    @ResponseBody
    public String readPost(@PathVariable int id) {
        User user = this.userService.getById(id);
        return String.format(user.getUsername() + "'s Blog: " + user.getBlogPost());
    }
}
```
