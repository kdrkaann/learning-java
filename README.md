# Kafein Staj - learning java

| G√ºn  | Konu |
| ------------- | ------------- |
| 1  | IDE se√ßimi ve Java‚Äôya ba≈ülangƒ±√ß  |
| 2  | Java‚Äôda deƒüi≈ükenler, temel veri tipleri, temel operat√∂rler ve control statements  |
| 3  | Java‚Äôda d√∂ng√ºler, diziler (arrays), string‚Äôler, paketler (packages), kullanƒ±cƒ±dan veri (input) alma  |
| 4  | Java‚Äôda metotlar (fonksiyonlar), class‚Äôlar (sƒ±nƒ±flar) ve kullanƒ±mlarƒ±  |
| 5  | Yazƒ±lƒ±m prensipleri ve OOP konseptine giri≈ü  |
| 6  | Java‚Äôda OOP - encapsulation (kaps√ºlleme), constructors (yapƒ±cƒ± bloklar) ve Access Modifiers  |
| 7  | Java‚Äôda OOP ‚Äì Inheritance (kalƒ±tƒ±m) ve metot overloading (a≈üƒ±rƒ± y√ºklenme)  |
| 8  | Java‚Äôda OOP ‚Äì Polymorphism (√ßok bi√ßimlilik), method overriding (metot ezme/ge√ßersiz kƒ±lma), Abstraction ve Abstract Class‚Äôlar (soyut sƒ±nƒ±f)  |
| 9  | Java‚Äôda OOP ‚Äì Interface (aray√ºzler), Inner Class ve Static terimi  |
| 10 | Java‚Äôda Collections (Koleksiyonlar) ‚Äì ArrayList ve Hashmap ve Java‚Äôda Exception Handling  |
| 11 | Java‚Äôda Generics ve Threading  |
| 12 | MySQL kurulumu, temel SQL sorgularƒ± ve Java‚Äôda JDBC ile database (veri tabanƒ±) baƒülantƒ±sƒ±  |
| 13 | Java‚Äôda JDBC ile veri tabanƒ± i≈ülemleri (SELECT, INSERT, UPDATE, DELETE) ve verileri nesnelere aktarma   |
| 14 | Java‚Äôda dosyalar ile √ßalƒ±≈ümak  |
             
## üìî Java 1. G√ºn
### IDE se√ßimi ve Java‚Äôya ba≈ülangƒ±√ß
Ment√∂r√ºm Hasan Bey Java i√ßin ≈üirkette ve profesyonel hayatta genellikle IntelliJ IDEA kullanƒ±ldƒ±ƒüƒ±nƒ± belirtti, aray√ºz√ºne de ≈üimdiden alƒ±≈ümam i√ßin IDE olarak IntelliJ IDEA‚Äôyƒ± tercih ettik. Uygulamayƒ± bilgisayarƒ±ma indirip kurdum.
Temel bilgileri edindikten sonra `System.out.print()` ve `System.out.println()` gibi output alma fonksiyonlarƒ±nƒ±n kullanƒ±mƒ±nƒ± √∂ƒürendim. Ardƒ±ndan a≈üaƒüƒ±daki gibi ‚Äúhello world!‚Äù benzeri ilk kodlarƒ±mƒ± yazdƒ±m.
```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world!");
        System.out.println("I'm Kadir Kaan.");
        System.out.println("I've finished my " + 2 + "year at Kadir Has University");
        System.out.println("I'm " + (12+8) + " years old.");
    }
}
```

## üìî Java 2. G√ºn
### Java‚Äôda deƒüi≈ükenler, temel veri tipleri, temel operat√∂rler ve control statements
Java‚Äôda temel veri tipleri olarak boolean, char, byte, short, int, long, float, double ve string bulunuyor. C++‚Äôta bulunan unsigned veri tipleri bulunmuyor, ayrƒ±ca C++‚Äôta bulunmayan byte veri tipi Java‚Äôda mevcut. Byte veri tipi tek byte‚Äôlƒ±k tam sayƒ± deƒüerlerini tutmak i√ßin kullanƒ±lƒ±yor.

Temel veri tiplerinden sonra temel operat√∂rler hakkƒ±nda bilgiler edindim. √ñrneƒüin, 
== e≈üittir, != e≈üit deƒüildir, > b√ºy√ºkt√ºr, < k√º√ß√ºkt√ºr, >= b√ºy√ºk e≈üittir, <= k√º√ß√ºk e≈üittir anlamƒ±na gelmekte. Ayrƒ±ca && ve(and), || veya(or), ! deƒüili(not) anlamƒ±na geliyor.

Sonrasƒ±nda control statements hakkƒ±nda bilgi edindim. Bunlar if, else if, else ve switch-case‚Äôdir. Control statements kullanarak a≈üaƒüƒ±daki gibi √∂rnekler yaptƒ±m.

```java
public class Main {
    public static void main(String[] args) {
        boolean flag = true;
        if(flag == true){
            System.out.println("Flag is true.");
        }
        else{
            System.out.println("Flag is false.");
        }

        char grade = 'A';
        switch (grade){
            case 'A':
                System.out.println("Well done!");
                break;
            case 'B':
                System.out.println("Great!");
                break;
            case 'C':
                System.out.println("Good!");
                break;
            case 'D':
                System.out.println("Enough.");
                break;
            case 'F':
                System.out.println("You should work harder!");
                break;
        }
    }
}
```

## üìî Java 3. G√ºn
### Java‚Äôda d√∂ng√ºler, diziler (arrays), string‚Äôler, paketler (packages), kullanƒ±cƒ±dan veri (input) alma
Java'da 3 tip d√∂ng√º bulunuyor. Bunlar For loop, While loop ve Do-While loop. √ú√ß√ºn√ºn de syntax‚Äôi C++ ile aynƒ± olduƒüu i√ßin hƒ±zlƒ±ca uyum saƒülayƒ±p birka√ß √∂rnek sonrasƒ± √∂ƒürenimime diziler (arrays) ile devam ettim.

Diziler, aynƒ± t√ºrden birden fazla deƒüi≈ükeni tutmamƒ±zƒ± saƒülayan hafƒ±za birimidir. Dizi olu≈üturduktan sonra dizinin i√ßerisindeki elemanlara indeks numarasƒ±yla ula≈üabilir ve deƒüi≈ütirebiliriz. Ayrƒ±ca, √ßok boyutlu diziler olu≈üturmak da m√ºmk√ºnd√ºr. ƒ∞ki boyutlu dizilere matris(matrix) denir. K√º√ß√ºk farklƒ±lƒ±klar dƒ±≈üƒ±nda Java‚Äôda dizi olu≈üturma a≈üamalarƒ± ve dizilerle yapƒ±lan i≈ülemler C++ ile olduk√ßa benzer. A≈üaƒüƒ±daki gibi √ße≈üitli √∂rneklerle √∂ƒürendiklerimi peki≈ütirdim.
```java
public class Main {
    public static void main(String[] args) {
        double[] arr = {1.7, 2.6, 9.3, 2.4, 8.4, 3.5};
        System.out.println(Arrays.toString(arr));
        double max = 0;
        double total = 0;
        for(double n : arr){
            if(max < n){
                max = n;
            }
            total += n;
        }
        System.out.println("Total: " + total);
        System.out.println("Max: " + max);
    }
}
```
Ardƒ±ndan Java‚Äôda string sƒ±nƒ±fƒ±nda yapƒ±labilen i≈ülemler hakkƒ±nda bilgi edindim. String sƒ±nƒ±fƒ± `charAt()`, `concat()`, `equals()`, `trim()`, `length()`, `substring()` ve `toLowerCase()` gibi fonksiyonlara sahip. Bu fonksiyonlarƒ±n i≈ülevlerini ve kullanƒ±mlarƒ±nƒ± √∂ƒürenip uyguladƒ±m. A≈üaƒüƒ±daki gibi √∂rnekler yaptƒ±m.
```java
public class Main {
    public static void main(String[] args) {
        String str = "Cristiano Ronaldo";
        System.out.println(str);
        System.out.println(str.charAt(3));
        
        System.out.println("-------");

        str = str.concat(" Portugal");
        System.out.println(str);

        System.out.println("-------");

        System.out.println(str.startsWith("C"));
        System.out.println(str.endsWith("a"));
```       
            
Java‚Äôda proje olu≈ütururken √∂zellikle b√ºy√ºk ve kapsamlƒ± projelerde sƒ±nƒ±flar mantƒ±ksal ve yapƒ±sal durumlarƒ±na g√∂re farklƒ± paketler (packages) altƒ±nda tutulurlar. C++‚Äôtaki k√ºt√ºphaneler gibi Java‚Äôda da Paketler bulunur. Paket Yapƒ±sƒ± kullanƒ±lmasƒ± hem kodun daha d√ºzenli olmasƒ±nƒ± hem kullanƒ±mƒ±n kolay olmasƒ±nƒ± hem de sƒ±nƒ±flarƒ±n birbirleriyle ileti≈üimlerinde meydana gelecek sƒ±nƒ±rlandƒ±rmalarƒ±n ayarlanabilmesini saƒülar. Paket yapƒ±sƒ± aslƒ±nda Java i√ßerisinde dosya yolu tanƒ±mlamaktƒ±r. Olu≈üturduƒüumuz sƒ±nƒ±flarƒ± farklƒ± paketler altƒ±na koymak aslƒ±nda bu sƒ±nƒ±flarƒ± farklƒ± dosya yollarƒ± i√ßerisine kaydetmek demektir. Bu dosya yollarƒ±yla Java hangi sƒ±nƒ±fa nereden eri≈üeceƒüini rahat bir ≈üekilde anlayabilir. Bir paket i√ßinde aynƒ± adƒ± ta≈üƒ±yan iki sƒ±nƒ±f ya da aray√ºz olamaz. Ama, farklƒ± paketler altƒ±nda sƒ±nƒ±f olu≈ütururken aynƒ± isimler kullanƒ±labilir.

Paket olu≈ütururken paket adƒ±ndan hemen √∂nce package anahtar s√∂zc√ºƒü√º yazƒ±lƒ±r. Genellikle sƒ±nƒ±ftan ayƒ±rmak i√ßin paket adlarƒ± k√º√ß√ºk harfle ba≈ülatƒ±lƒ±r. Paketler ba≈üka paketleri import edebilir. Bir paketi dahil edebilmek i√ßin import anahtar kelimesi kullanƒ±lƒ±r. Eƒüer bir paketteki belirli bir alt paketi/sƒ±nƒ±fƒ± import edeceksek, ana paket isminden sonra nokta koyup alt paketin/sƒ±nƒ±fƒ±n adƒ±nƒ± yazarƒ±z. Eƒüer bir alt paketin i√ßindeki her ≈üeyi import etmek istiyorsak noktadan sonra * ekleriz. Ayrƒ±ca, static olarak tanƒ±mlanmƒ±≈ü deƒüi≈üken ve metotlarƒ± sanki import ettiƒüimiz sƒ±nƒ±fƒ±n bir par√ßasƒ±ymƒ±≈ü gibi kullanabilmek i√ßin import static deyimi kullanƒ±lƒ±r.

Paketler hakkƒ±nda bilgi sahibi olduktan sonra kullanƒ±cƒ±dan veri (input) almak hakkƒ±nda bilgi edinmeye ba≈üladƒ±m.

Java‚Äôda kullanƒ±cƒ±dan veri almak i√ßin Scanner sƒ±nƒ±fƒ± kullanƒ±lƒ±r. Ama bu sƒ±nƒ±fƒ± kullanmadan √∂nce kodumuza Scanner sƒ±nƒ±fƒ±nƒ± dahil (import) etmemiz gerekir. Ardƒ±ndan Scanner sƒ±nƒ±fƒ±na ait bir nesne tanƒ±mlanƒ±r ve bu nesnenin fonksiyonlarƒ±yla input alƒ±mƒ± yapƒ±lƒ±r. Alƒ±nacak verinin t√ºr√ºne g√∂re `nextInt()`, `nextDouble()`, `nextLine()` gibi fonksiyonlar kullanƒ±lƒ±r.

Listeler, string‚Äôler, paketler ve input alma hakkƒ±nda √∂ƒürendiklerimi bir araya getirip a≈üaƒüƒ±daki gibi √ße≈üitli uygulamalar olu≈üturdum.
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("Write a number to check: ");
        int num = input.nextInt();

        if(num == 1){
            System.out.println("It is not a prime number.");
            return;
        }
        else if(num <= 0){
            System.out.println("Invalid number.");
            return;
        }
        boolean isPrime = true;
        for(int i = 2; i < num; i++){
            if(num % i == 0){
                isPrime = false;
                break;
            }
        }
        if(isPrime){
            System.out.println("It is a prime number.");
        }
        else{
            System.out.println("It is not a prime number.");
        }
    }
}
```
## üìî Java 4. G√ºn
### Java‚Äôda metotlar (fonksiyonlar), class‚Äôlar (sƒ±nƒ±flar) ve kullanƒ±mlarƒ±
Java'da metotlar sadece √ßaƒürƒ±ldƒ±ƒüƒ±nda kullanƒ±lan kod bloklarƒ±dƒ±r. Bir program i√ßindeki main metodu √ßaƒüƒ±rƒ±larak √ßalƒ±≈ütƒ±rƒ±lƒ±r. Metotlara bir diƒüer adlandƒ±rma olarak fonksiyon da denilmektedir. Bunun sebebi bu kod yapƒ±sƒ±nƒ±n matematikteki fonksiyon mantƒ±ƒüƒ±na √ßok benzemesidir. Java'da metotlarƒ±mƒ±zƒ±n i√ßerisine veri aktarmak i√ßin parametre girebilmekteyiz. Java‚Äôda metotlara girilen parametreler reference olarak deƒüil value olarak aktarƒ±lƒ±yor, yani aktarƒ±lan verinin kendisi deƒüil otomatik olu≈üturulan kopyasƒ± fonksiyonun i√ßinde i≈ülem g√∂r√ºyor. Ayrƒ±ca Java metoda girilecek parametre belirtilirken C++‚Äôta bulunmayan bir √∂zelliƒüe sahip. Bu da veri tipinin yanƒ±na √º√ß nokta koyularak (√∂r: int...) o tipte birden fazla deƒüeri, ka√ß tane olduƒüundan baƒüƒ±msƒ±z olarak metoda yollayabiliyoruz. Yani bu kullanƒ±mla int... olarak belirttiƒüimiz parametreye ka√ß tane integer deƒüeri girmemiz gerektiƒüi hakkƒ±nda bir kƒ±sƒ±tlama yok. 1 tane de girebiliriz 20 tane de. Java bu deƒüerleri alƒ±p bir array‚Äôe √ßeviriyor ve √ºst√ºnde bir array gibi √ßalƒ±≈üƒ±yor. 

Metotlar hakkƒ±nda bilgi sahibi olup birka√ß √∂rnek yaptƒ±ktan sonra Class‚Äôlar √ºzerine √ßalƒ±≈ümaya ba≈üladƒ±m. Java Nesne Y√∂nelimli bir programlama dilidir. Java'daki her ≈üey, deƒüi≈ükenleri ve metotlarƒ± ile birlikte sƒ±nƒ±flar ve nesnelerle ili≈ükilidir. √ñrneƒüin: ger√ßek hayatta araba bir nesnedir. Arabanƒ±n aƒüƒ±rlƒ±k ve renk gibi deƒüi≈ükenleri ve s√ºr√º≈ü ve fren gibi metotlarƒ± vardƒ±r. Nesne y√∂nelimli programlamanƒ±n amacƒ± yazdƒ±ƒüƒ±mƒ±z kodlara soyut bir kavrama d√∂n√º≈üt√ºrmektir. Sƒ±nƒ±flara ait nitelikler ve davranƒ±≈ülar vardƒ±r. Programlamada nitelikler (attributes) i√ßin deƒüi≈ükenler (variable), davranƒ±≈ülar i√ßin ise metotlar tanƒ±mlanƒ±r. Java‚Äôda sƒ±nƒ±f isimleri olu≈üturulan Java dosyasƒ±yla aynƒ± isme sahip olmalƒ±dƒ±r. Java'da nesne √ºretmek i√ßin C++‚Äôta olduƒüu gibi "new" anahtar kelimesini kullanƒ±rƒ±z.

Sƒ±nƒ±flara ait niteliklere eri≈üim saƒülamak i√ßin nokta (.) kullanƒ±lƒ±r. ƒ∞lgili nesnenin ismini sonuna nokta koyularak eri≈üilmek istenilen niteliƒüin ismi yazƒ±lƒ±r. Aynƒ± ≈üekilde, sƒ±nƒ±fa ait davranƒ±≈ülara yani metotlara eri≈ümek i√ßin nokta (.) kullanƒ±lƒ±r. ƒ∞lgili nesnenin ismini sonuna nokta koyularak eri≈üilmek istenilen metodun ismi yazƒ±lƒ±r ve var ise parametreleri girilir.

Ek olarak, SOLID yazƒ±lƒ±m prensibine g√∂re bir metodun veya sƒ±nƒ±fƒ±n yalnƒ±zca bir sorunu √ß√∂zmesi, yapmasƒ± gereken sadece bir i≈üi olmasƒ± gerekir. 

C++ ile olduk√ßa benzer olan Java class syntax‚Äôƒ±na alƒ±≈ümam kolay oldu ve farklƒ± √∂rnek sƒ±nƒ±flar olu≈üturmaya ba≈üladƒ±m. Sonrasƒ±nda ise metotlar ve sƒ±nƒ±flar hakkƒ±nda √∂ƒürendiklerimi birle≈ütirmek ve peki≈ütirmek i√ßin bir basit hesap makinesi sƒ±nƒ±fƒ± yazdƒ±m.
```java
public class Calculator {
    public int sum(int... nums){
        int result = 0;
        for(int num : nums){
            result += num;
        }
        return result;
    }
    public int subtract(int... nums){
        int result = 0;
        for(int num : nums){
            result -= num;
        }
        return result;
    }
    public int multiply(int... nums){
        int result = 1;
        for(int num : nums){
            result *= num;
        }
        return result;
    }
    public double divide(double num1, double num2){
        return num1/num2;
    }
    public int remainder(int num1, int num2){
        return num1%num2;
    }
    public int square(int num){
        return num*num;
    }
}
```

## üìî Java 5. G√ºn
### Yazƒ±lƒ±m prensipleri ve OOP konseptine giri≈ü
‚Ä¢	S.O.L.I.D. tasarƒ±m ilkeleri a≈üaƒüƒ±dakilerden olu≈üur:

S- Single Responsibility Principle (Tek Sorumluluk Prensibi): 
Her mod√ºl (sƒ±nƒ±f, metot vb.), yazƒ±lƒ±mƒ±n saƒüladƒ±ƒüƒ± i≈ülevselliƒüin tek bir par√ßasƒ± √ºzerindeki sorumluluƒüunu yerine getirecek ≈üekilde tasarlanmalƒ±dƒ±r.

O- Open/Closed Principle (A√ßƒ±k/Kapalƒ± Prensibi): 
Geli≈ütirilen yazƒ±lƒ±mdaki nesnelerin geli≈ütirmeye a√ßƒ±k ama deƒüi≈üime kapalƒ± olmasƒ± gerekir. Yazƒ±lƒ±mda herhangi bir g√ºncelleme yapƒ±lmasƒ± durumunda temel nesnenin deƒüi≈üime kapalƒ± tutulmasƒ± gerekir. Bir nesne ek √∂zellik kazandƒ±ysa bu nesne geni≈ületilebilir fakat temel nesne deƒüi≈ütirilmemelidir.

L- Liskov‚Äôs Substitution Principle (Liskov‚Äôun ƒ∞kame ‚ÄúYerine Ge√ßme‚Äù Prensibi): 
Miras alarak t√ºremi≈ü olan sƒ±nƒ±flarƒ±n √∂nce miras aldƒ±klarƒ± nesnenin t√ºm √∂zelliklerini kullanmasƒ±, sonra da kendi √∂zelliklerini barƒ±ndƒ±rmasƒ± gerekir. Eƒüer olu≈üturulan sƒ±nƒ±f, miras aldƒ±ƒüƒ± nesnenin t√ºm √∂zelliklerini kullanmazsa ortaya gereksiz kod bloklarƒ± √ßƒ±kar.

I- Interface Segregation Principle (Aray√ºz Ayrƒ±≈ütƒ±rma Prensibi): 
Bir aray√ºze (interface) gereƒüinden fazla i≈ü y√ºklemek yerine bu i≈üler i√ßin birden fazla aray√ºzler olu≈üturulmalƒ±dƒ±r. Bu prensibin amacƒ± nesnelere, ihtiyacƒ± olmayan √∂zellik veya fonksiyonlar i√ßeren aray√ºz uygulamamaktƒ±r.

D- Dependency Inversion Principle (Baƒüƒ±mlƒ±lƒ±k Tersine √áevirme Prensibi): 
Alt sƒ±nƒ±flarƒ±n √ºst sƒ±nƒ±flarƒ± etkilememesi, sƒ±nƒ±flar arasƒ±ndaki baƒüƒ±mlƒ±lƒ±klarƒ±n olabildiƒüince az olmasƒ± gerekir. √ñzellikle y√ºksek seviyeli sƒ±nƒ±flar, d√º≈ü√ºk seviyeli sƒ±nƒ±flara baƒülƒ± olmamalƒ±dƒ±r.

‚Ä¢	KISS ‚Äî Keep It Simple, Stupid (Basit Tut, Aptal):

‚ÄúKeep It Simple, Stupid‚Äù ilkesi bize t√ºm yazƒ±lƒ±m veya uygulama tasarƒ±mƒ±nƒ±n ve daƒüƒ±tƒ±mƒ±nƒ±n m√ºmk√ºn olduƒüunca basit, en az karma≈üƒ±klƒ±kla ve geli≈ütirme prosed√ºrlerini anlamak i√ßin anla≈üƒ±lƒ±r ≈üekilde yapƒ±lmasƒ± gerektiƒüini hatƒ±rlatƒ±r. Bu ilke, kaynak kodun hata ayƒ±klamasƒ±nƒ±n kolay hale getirilmesini ve gelecekteki herhangi bir operasyon ve bakƒ±mƒ±n (maintenance) daha kolay olmasƒ±nƒ± saƒülar.

‚Ä¢	DRY ‚Äî Don‚Äôt Repeat Yourself (Kendini Tekrar Etme):

‚ÄúDon‚Äôt Repeat Yourself‚Äù ilkesi bize, her yazƒ±lƒ±m m√ºhendisinin, fazlalƒ±klardan ka√ßƒ±nmak i√ßin √ßalƒ±≈ümalarƒ±nda bilgi veya y√∂ntemlerin tekrarƒ±nƒ± azaltmayƒ± hedeflemesi gerektiƒüini s√∂yler. Bu nedenle, t√ºm deƒüerlendirme sistemini par√ßalara ayƒ±rmanƒ±z √∂nerilir. Kodu daha k√º√ß√ºk par√ßalara b√∂lmek, kodu y√∂netmeye ve gerektiƒüinde arayarak herhangi bir noktada tek bir par√ßa kullanmaya yardƒ±mcƒ± olabilir.

Sonrasƒ±nda OOP (Object Oriented Programming / Nesne Y√∂nelimli Programlama) konsepti hakkƒ±nda bilgi sahibi oldum. Nesne Y√∂nelimli Programlama, sƒ±nƒ±flar ve nesneler kavramƒ±na dayanan bir programlama yakla≈üƒ±mƒ±dƒ±r. Bu yakla≈üƒ±mƒ±n amacƒ±, ihtiya√ß duyulan programƒ± daha k√º√ß√ºk par√ßalara b√∂lerek, y√∂netilebilir ve yeniden kullanƒ±labilir hale getirmektir. 

‚Ä¢	OOP, programlar i√ßin net bir yapƒ± saƒülar. DRY, KISS gibi ilkeleri uygular ve kodun bakƒ±mƒ±nƒ±, d√ºzenlenmesini ve hata ayƒ±klamasƒ±nƒ± kolayla≈ütƒ±rƒ±r.

‚Ä¢	OOP, daha az kod ve daha kƒ±sa geli≈ütirme s√ºresiyle, yeniden kullanƒ±labilir uygulamalar olu≈üturmayƒ± m√ºmk√ºn kƒ±lar.

‚Ä¢	OOP, yapƒ±ya daha sonradan yeni √∂zellikler ekleyerek geni≈ületilebilirlik saƒülar.

‚Ä¢	OOP, problemleri ger√ßek hayattaki i≈ülemlere g√∂re modeller.

Nesne Y√∂nelimli Programlama ile bizler yapacaƒüƒ±mƒ±z her ≈üeyi bilgisayarƒ±n anlayacaƒüƒ± ≈üekilde modelleyip, ‚Äúnesne‚Äù halinde aktarƒ±yoruz. B√∂ylelikle ger√ßek hayatta bizim i√ßin ge√ßerli olan nesneleri artƒ±k bilgisayarlarƒ±n anlayacaƒüƒ± hale getirmi≈ü oluyoruz.

## üìî Java 6. G√ºn
### Java‚Äôda OOP - encapsulation (kaps√ºlleme), constructors (yapƒ±cƒ± bloklar) ve Access Modifiers
Encapsulation ilkesi, bir sƒ±nƒ±fa ait deƒüi≈ükenlerin veya niteliklerin ancak o sƒ±nƒ±fa ait metotlar tarafƒ±ndan deƒüi≈ütirilebilmesi ve okunabilmesi ilkesidir. Bu ilke sayesinde nesnelerde olu≈üacak anlamsƒ±zlƒ±klarƒ±n √∂n√ºne ge√ßilebilir.

Ayrƒ±ca deƒüi≈ükenlere sƒ±nƒ±flarƒ±n dƒ±≈üƒ±ndan eri≈üim olmamasƒ± ve bir sƒ±nƒ±f i√ßindeki deƒüi≈ükenlerin nasƒ±l ve ne kadar olacaƒüƒ±nƒ±n da ba≈üka kodlardan saklanmƒ±≈ü olmasƒ± anlamƒ±na gelir. B√∂ylelikle biz deƒüi≈ükenlerimizi sarmalayarak istenmeyen durumlardan korunacak bir filtre haline d√∂n√º≈üt√ºrebiliriz.

Bir sƒ±nƒ±fa ait nitelik ve davranƒ±≈ülara eri≈üebilmek i√ßin Access Modifiers (Eri≈üim Belirleyiciler) kullanƒ±lƒ±r. Java‚Äôda Access Modifiers deƒüi≈üken metot ve sƒ±nƒ±flarƒ±n √∂n√ºne yazƒ±lƒ±r ve yazƒ±ldƒ±klarƒ± konunun eri≈üilebilecekleri alanƒ± belirlerler.

Java‚Äôda 3 adet Access Modifier mevucttur. Bunlar Private, Public ve Protected‚Äôdƒ±r. 

‚Ä¢	Private: yazƒ±ldƒ±ƒüƒ± √∂ƒüenin sadece o sƒ±nƒ±f tarafƒ±ndan eri≈üilebilir olduƒüunu ve o sƒ±nƒ±fƒ±n dƒ±≈üƒ±ndaki kodlardan doƒürudan eri≈üim olmadƒ±ƒüƒ±nƒ± tanƒ±mlar. 
‚Ä¢	Public: yazƒ±ldƒ±ƒüƒ± √∂ƒüenin sadece ait olduƒüu sƒ±nƒ±f i√ßin deƒüil diƒüer sƒ±nƒ±flar tarafƒ±ndan da doƒürudan eri≈üilebilir olmasƒ±nƒ± saƒülar. 
‚Ä¢	Protected: Public ve Private arasƒ±nda kalan eri≈üim d√ºzenleyicidir. Protected ile tanƒ±mlanan √∂ƒüeler kendisi ile aynƒ± pakette (package) bulunan sƒ±nƒ±flar tarafƒ±ndan doƒürudan eri≈üilebilir.

Bir sƒ±nƒ±fa ait private deƒüi≈ükenlere ula≈ümak i√ßin Getter metotlarƒ± kullanƒ±lƒ±r. Bir sƒ±nƒ±fa ait private deƒüi≈ükenlerin deƒüerini deƒüi≈ütirmek i√ßin ise Setter metotlarƒ± kullanƒ±lƒ±r.
```java
public class Product {
    private String name;
    private String description;
    private double price;
    private int id;
    private int stockAmount;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return this.description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public double getPrice() {
        return this.price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public int getId() {
        return this.id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getStockAmount() {
        return this.stockAmount;
    }

    public void setStockAmount(int stockAmount) {
        this.stockAmount = stockAmount;
    }
}
```
           
Yapƒ±cƒ± metotlar sƒ±nƒ±f tasarlanƒ±rken yazƒ±lƒ±rlar. Eƒüer sƒ±nƒ±f i√ßinde hi√ß yapƒ±cƒ± metot tanƒ±mlanmazsa parametresiz bo≈ü bir yapƒ±cƒ± metot Java tarafƒ±ndan otomatik olarak tanƒ±mlanƒ±r. Yapƒ±cƒ± metotlarƒ±n isimleri Sƒ±nƒ±f ismiyle aynƒ± olmak zorundadƒ±r. D√∂n√º≈ü tipi olarak veya void olarak herhangi bir tanƒ±mlama yapƒ±lmasƒ±na gerek yoktur. Sonrasƒ±nda bu sƒ±nƒ±fa ait bir nesne olu≈üturulduƒüunda nesnenin nitelikleri(attributes) null‚Äôa e≈üit olur. 

Yukarƒ±da olu≈üturduƒüum Product sƒ±nƒ±fa bir constructor (yapƒ±cƒ± metot) yazƒ±lmadƒ±ƒüƒ± i√ßin Java otomatik tanƒ±mlanan constructor‚Äôƒ± kullanarak sƒ±nƒ±f i√ßin tanƒ±mlanan niteliklere sahip bir nesne olu≈üturdu ve bu nitelikleri null‚Äôa e≈üitledi. Eƒüer otomatik tanƒ±mlanan yapƒ±cƒ± metotun (default constructor) bizim tanƒ±mladƒ±ƒüƒ±mƒ±z bir constructor varken de kullanƒ±labilmesini istiyorsak parametresiz ve i√ßi bo≈ü bir constructor metodu yazmamƒ±z gerekiyor.
       
Yazdƒ±ƒüƒ±m Product sƒ±nƒ±fƒ±na name, description, stockAmount, price ve id niteliklerinin parametre olarak verildiƒüi bir constructor yazdƒ±m. Default constructor‚Äôƒ±n da kullanƒ±labilir olmasƒ± i√ßin onu da i√ßi bo≈ü bir ≈üekilde tanƒ±mladƒ±m.
```java
Product(){

}
Product(String name, String description, double price, int id, int stockAmount){
    this.name = name;
    this.description = description;
    this.price = price;
    this.id = id;
    this.stockAmount = stockAmount;
}    
```

## üìî Java 7. G√ºn
### Java‚Äôda OOP ‚Äì Inheritance (kalƒ±tƒ±m) ve metot overloading (a≈üƒ±rƒ± y√ºklenme)
Java‚Äôda bir metodu farklƒ± t√ºrde, sayƒ±da veya sƒ±rada parametre ile olu≈üturmak istiyorsak yani aynƒ± metodun farklƒ± versiyonlarƒ± olu≈üturulmak isteniyorsa metotlara overloading (a≈üƒ±rƒ± y√ºkleme) yapƒ±lƒ±r. Metotlar aynƒ± isme sahip olur ancak parametreleri farklƒ±lƒ±k g√∂sterir. Farklƒ± constructor metotlarƒ± olu≈üturmaya benzer.

A≈üaƒüƒ±daki √∂rnekte bir example fonksiyonu tanƒ±mladƒ±m ve overloading ile √º√ß farklƒ± versiyonunu olu≈üturdum.
```java
    public static int example(int a, int b){
        return a + b;
    }
    public static int example(int a, int b, int c){
        return a + b - c;
    }
    public static int example(int a, int b, int c, int d){
        return a * b + c - d;
    }
```

       
Bir sƒ±nƒ±fƒ±n ba≈üka bir sƒ±nƒ±ftan kalƒ±tƒ±m yapmasƒ± (inheritance) demek, kalƒ±tƒ±mƒ± yapan sƒ±nƒ±fƒ±n diƒüer sƒ±nƒ±ftaki nitelik ve davranƒ±≈ülarƒ±nƒ± (metotlarƒ±nƒ±) kendisine almasƒ±, kullanabilmesi demektir. Kalƒ±tƒ±mƒ± yapan sƒ±nƒ±fa alt sƒ±nƒ±f, kendisinden kalƒ±tƒ±m yapƒ±lan sƒ±nƒ±fa ata sƒ±nƒ±f dersek, ata sƒ±nƒ±fta tanƒ±mlƒ± olan her ≈üeyin alt sƒ±nƒ±f i√ßin de tanƒ±mlƒ± olduƒüunu s√∂yleyebiliriz. Kalƒ±tƒ±m Java‚Äôda ‚Äúextends‚Äù kelimesi ile tanƒ±mlanƒ±r. √ñrneƒüin A sƒ±nƒ±fƒ±nƒ±n B sƒ±nƒ±fƒ±ndan kalƒ±tƒ±m yapmasƒ±nƒ± istiyorsak A sƒ±nƒ±fƒ±nƒ± tanƒ±mlarken ‚Äúpublic Class A extends B‚Äù ≈üeklinde yazarƒ±z.

Kalƒ±tƒ±mƒ±n kavramƒ±nƒ±n bir√ßok farklƒ± t√ºr√º bulunmakta:

‚Ä¢	Tek Y√∂nl√º Kalƒ±tƒ±m (Single Inheritance): Bir sƒ±nƒ±fƒ±n ba≈üka bir sƒ±nƒ±fƒ± geni≈ülettiƒüi, alt ve ata sƒ±nƒ±f ili≈ükisini ifade eder.

‚Ä¢	√áoklu Kalƒ±tƒ±m (Multiple Inheritance): Bir sƒ±nƒ±fƒ±n birden fazla sƒ±nƒ±fƒ± miras almasƒ±nƒ± ifade eder. Yani bir alt sƒ±nƒ±fƒ±n iki ata sƒ±nƒ±fa sahip olduƒüu anlamƒ±na gelir. Java multiple inheritance‚Äôƒ± desteklemez.

‚Ä¢	√áok Seviyeli Kalƒ±tƒ±m (Multilevel Inheritance): Bir sƒ±nƒ±fa ait alt sƒ±nƒ±fƒ±n ba≈üka sƒ±nƒ±flarƒ± geni≈ületmesine denir.

‚Ä¢	Hiyerar≈üik Kalƒ±tƒ±m (Hierarchical Inheritance): Birden fazla sƒ±nƒ±fƒ±n aynƒ± sƒ±nƒ±fƒ± geni≈ülettiƒüi bir alt ve √ºst sƒ±nƒ±f ili≈ükisini ifade eder. Yani bir ata sƒ±nƒ±fƒ±n birden √ßok alt sƒ±nƒ±fƒ± vardƒ±r.

‚Ä¢	Hibrit Kalƒ±tƒ±m (Hybrid Inheritance): Programda birden fazla kalƒ±tƒ±m t√ºr√ºn√ºn kombinasyonuna denir. √ñrneƒüin, A ve B sƒ±nƒ±fƒ±, C sƒ±nƒ±fƒ±nƒ± geni≈ületir ve ba≈üka bir D sƒ±nƒ±fƒ±, A sƒ±nƒ±fƒ±nƒ± geni≈ületir, bu bir hibrit kalƒ±tƒ±m √∂rneƒüidir √ß√ºnk√º bu durum tek y√∂nl√º ve hiyerar≈üik kalƒ±tƒ±mƒ±n bir birle≈üimidir.

Ek olarak, ata sƒ±nƒ±fƒ±n tipinde tanƒ±mlanan bir parametreye, o ata sƒ±nƒ±fƒ±n alt sƒ±nƒ±flarƒ±nƒ±n tipinde bir deƒüi≈üken yazƒ±lƒ±rsa kod sorunsuz √ßalƒ±≈üƒ±r √ß√ºnk√º alt sƒ±nƒ±flar ata sƒ±nƒ±fƒ±n da √∂zelliklerini i√ßerir.
A≈üaƒüƒ±daki √∂rnekte bir A sƒ±nƒ±fƒ± tanƒ±mladƒ±m. Sonrasƒ±nda A sƒ±nƒ±fƒ±nƒ±n alt sƒ±nƒ±fƒ± olan bir B sƒ±nƒ±fƒ± tanƒ±mladƒ±m. Sonra da B sƒ±nƒ±fƒ±nƒ±n alt sƒ±nƒ±fƒ± olan C sƒ±nƒ±fƒ± tanƒ±mladƒ±m.
```java
public class A {
    public int sum(int n, int m){
        return n + m;
    }
}
```
```java
public class B extends A{
    public int multiplication(int n, int m){
        return n * m;
    }
}
```
```java
public class C extends B{
    public int remainder(int n, int m){
        return n % m;
    }
}
```
C sƒ±nƒ±fƒ±ndan olu≈üturduƒüum nesneyle A ve B sƒ±nƒ±flarƒ±nƒ±n fonksiyonlarƒ±nƒ± √ßalƒ±≈ütƒ±rabildim. Ardƒ±ndan B sƒ±nƒ±fƒ±ndan olu≈üturduƒüum nesneyle de A sƒ±nƒ±fƒ±nƒ±n `sum()` metodunu kullanabildim. √á√ºnk√º C sƒ±nƒ±fƒ± B‚Äônin, B sƒ±nƒ±fƒ± da A‚Äônƒ±n alt sƒ±nƒ±fƒ±.

## üìî Java 8. G√ºn
### Java‚Äôda OOP ‚Äì Polymorphism (√ßok bi√ßimlilik), method overriding (metot ezme/ge√ßersiz kƒ±lma), Abstraction ve Abstract Class‚Äôlar (soyut sƒ±nƒ±f)
Polymorphism bir √ºst sƒ±nƒ±f referansƒ±nƒ±n t√ºm alt sƒ±nƒ±f nesnelerini tutabilmesidir. Yani bir √ºst sƒ±nƒ±f referansƒ±na tanƒ±mlanan bir deƒüeri, o sƒ±nƒ±fƒ±n alt sƒ±nƒ±flarƒ±nƒ±n tipinde deƒüi≈ükenler yazarak √ßalƒ±≈ütƒ±rabiliriz.
	
Ayrƒ±ca Polymorphism, alt sƒ±nƒ±flarƒ±n ata sƒ±nƒ±flardaki metotlarƒ± method overriding sayesinde ge√ßersiz kƒ±lmasƒ±, √ßok bi√ßimli olarak davranmasƒ±na denir. Bu sayede alt sƒ±nƒ±f ata sƒ±nƒ±fƒ±ndan gelen davranƒ±≈üƒ± kendine g√∂re ≈üekillendirebilir.

Method overriding (metot ezme/ge√ßersiz kƒ±lma) bir alt sƒ±nƒ±fƒ±n i√ßine, doƒürudan ya da dolaylƒ± olarak ata sƒ±nƒ±flarƒ±ndan gelen bir y√∂ntemin aynƒ±sƒ±nƒ±n, aynƒ± y√∂ntem adƒ± ve aynƒ± parametrelere sahip olarak, kodlanmasƒ±na verilen addƒ±r. Java‚Äôda bu i≈ülem metottan √∂nce yazƒ±lan @Override ifadesi ile kullanƒ±lƒ±r. Eƒüer bir metodun override edilememesi isteniyorsa, bu metot final ifadesi kullanƒ±larak tanƒ±mlanƒ±r.

Polymorphism sayesinde uygulamalarƒ±n geni≈ületilebilirliƒüini saƒülarƒ±z. Ata sƒ±nƒ±fƒ±n sunduƒüu y√∂ntemleri ge√ßersiz kƒ±lan alt sƒ±nƒ±flar yardƒ±mƒ± ile ata sƒ±nƒ±fa g√∂re kodlanmƒ±≈ü bir kod kesimine (metot vb.) farklƒ± davranƒ±≈ülar y√ºkleme imkanƒ±mƒ±z olmaktadƒ±r. Yani, elimizde esnek bir altyapƒ± var denebilir. 

A≈üaƒüƒ±daki √∂rnekte Polymorphism ve overriding‚Äôi birlikte kullanarak bir kredi hesaplama programƒ± yazdƒ±m. Bu programda BaseLoanManager adƒ±nda bir ata sƒ±nƒ±f ve bu sƒ±nƒ±fƒ±n alt sƒ±nƒ±flarƒ± olan AgricultureLoanManager, StudentLoanManager, TeacherLoanManager sƒ±nƒ±flarƒ±nƒ± yazdƒ±m.

Base sƒ±nƒ±fa faiz oranƒ±nƒ± 1,18 olarak tanƒ±mladƒ±m ve bir calculate (hesaplama) metodu yazdƒ±m. Diƒüer alt sƒ±nƒ±flar i√ßin de hesaplama metodunu override ettim ve hesaplamalarƒ± farklƒ± faiz oranlarƒ± ile yaptƒ±m.
```java
public class BaseLoanManager {
    public double calculate(double amount){
        return amount * 1.18;
    }
}
```
```java
public class AgricultureLoanManager extends BaseLoanManager{
    @Override
    public double calculate(double amount){
        return amount * 1.15;
    }
}
```
```java
public class StudentLoanManager extends BaseLoanManager{
    @Override
    public double calculate(double amount){
        return amount * 1.10;
    }
}
```
```java
public class TeacherLoanManager extends BaseLoanManager{
    @Override
    public double calculate(double amount) {
        return amount * 1.13;
    }
}
```
        
Abstraction (soyutlama), bir sƒ±nƒ±fa veya metoda temel g√∂revlerin tanƒ±mlanmasƒ±, detaylarƒ±n ise tanƒ±mlanmamasƒ± demektir. Temel olarak bir soruna ait √ß√∂z√ºme giderken kullanƒ±lacak y√∂ntemlerin, ilk etapta daha genel basit ve soyut bir tanƒ±mƒ±nƒ± yapmaktƒ±r. Alt sƒ±nƒ±flarƒ±n ortak √∂zelliklerini ve i≈ülevlerini ta≈üƒ±yan ancak hen√ºz bir nesnesi olmayan bir √ºst sƒ±nƒ±f olu≈üturmak istenirse bir abstract (soyut) √ºst sƒ±nƒ±f olu≈üturulur. Soyutlama i√ßin Java'da iki y√∂ntem mevcuttur: abstract sƒ±nƒ±f tanƒ±mlamak ve interface tanƒ±mlamak.

Abstract sƒ±nƒ±flar, "abstract" anahtar kelimesi ile tanƒ±mlanan sƒ±nƒ±flardƒ±r. Sƒ±nƒ±fƒ±n i√ßinde soyut (abstract) metotlar veya normal metotlar tanƒ±mlanabilir. Abstract olarak tanƒ±mlanan metotlarƒ±n abstract sƒ±nƒ±f i√ßinde tanƒ±mƒ± yapƒ±lmaz ve inherit eden alt sƒ±nƒ±flarda √∂zel olarak tanƒ±mlarƒ±nƒ±n yapƒ±lmasƒ± gerekir. Ayrƒ±ca soyut sƒ±nƒ±flardan new anahtar kelimesi ile bir nesne olu≈üturulamaz. Abstract sƒ±nƒ±flar da polymorphism √∂zelliƒüi sayesinde alt sƒ±nƒ±flarƒ±nƒ±n referansƒ±nƒ± tutabilirler.

A≈üaƒüƒ±daki √∂rnekte abstract class‚Äôlarƒ± kullanarak bir prototip Database Manager √∂rneƒüi olu≈üturdum. Bunun i√ßin bir abstract BaseDatabaseManager sƒ±nƒ±fƒ± olu≈üturdum. Farklƒ± SQL server‚Äôlarƒ±n farklƒ± kodlarƒ± olabildiƒüi i√ßin abstract olarak olu≈üturduƒüum bu √ºst sƒ±nƒ±fta getData adlƒ± bir abstract metot olu≈üturdum. B√∂ylece spesifik SQL server tiplerini kullanmak i√ßin olu≈üturulacak alt sƒ±nƒ±flarda, getData metodunun kodlarƒ±nƒ±n o server tipi i√ßin √∂zel olarak tanƒ±mlanmasƒ± gerekecektir. Ardƒ±ndan bir de CustomerManager sƒ±nƒ±fƒ± olu≈üturdum. Burada ama√ß CustomerManager sƒ±nƒ±fƒ±nƒ±n i√ßindeki getCustomers metodunu kullanarak SQL server‚Äôlardan m√º≈üteri verisi √ßeken bir prototip uygulama yapmak. √ñrnek alt sƒ±nƒ±f olarak da OracleDatabaseManager ve MySqlDatabaseManager sƒ±nƒ±flarƒ±nƒ± olu≈üturdum.
```java
public abstract class BaseDatabaseManager {
    public abstract void getData();
}
```
```java
public class OracleDatabaseManager extends BaseDatabaseManager{
    @Override
    public void getData() {
        System.out.println("Getting the data - Oracle...");
        //Oracle database codes
    }
}
```
```java
public class MySqlDatabaseManager extends BaseDatabaseManager{
    @Override
    public void getData() {
        System.out.println("Getting the data - MySql...");
        //MySql database codes
    }
}
```
```java
public class CustomerManager {
    BaseDatabaseManager databaseManager;

    public void getCustomers(){
        databaseManager.getData();
    }
}
```

## üìî Java 9. G√ºn
### Java‚Äôda OOP ‚Äì Interface (aray√ºzler), Inner Class ve Static terimi
Java'da soyutlamayƒ± saƒülamanƒ±n bir ba≈üka yolu da interface tanƒ±mlamaktƒ±r. 
Interface'lerin abstract class‚Äôlara g√∂re soyutlama oranƒ± √ßok y√ºksektir. √á√ºnk√º, abstract class‚Äôlarda soyut olmayan fonksiyonlar da tanƒ±mlanabilirken, interface‚Äôler i√ßinde sadece soyut fonksiyonlar tanƒ±mlanabiliyor. Metot g√∂vdesi olan normal fonksiyonlar tanƒ±mlanamƒ±yor. Bu soyut metotlarƒ±n implement eden sƒ±nƒ±flar tarafƒ±ndan, aynƒ± abstract class‚Äôlarda olduƒüu gibi, √∂zel olarak tanƒ±mlanmasƒ± gerekiyor. Bir sƒ±nƒ±f bir interface‚Äôden kalƒ±tƒ±m alƒ±yorsa implements anahtar kelimesi kullanƒ±lƒ±r.

Bir sƒ±nƒ±f birden fazla interface‚Äôi inherit olarak alabilir (implement) ancak birden fazla abstract class‚Äôƒ± inherit alamaz (extend). Ayrƒ±ca, Abstract class‚Äôlarda t√ºm √∂ƒüelerin ‚Äúpublic‚Äù olmasƒ± zorunlu deƒüilken Interface i√ßerisindeki t√ºm nesnelerin public olmasƒ± gerekir. Abstract class‚Äôlarda olduƒüu gibi interface‚Äôlerde de new anahtar kelimesi ile nesne olu≈üturulamaz. Ayrƒ±ca interface‚Äôde tanƒ±mlanan deƒüi≈ükenler interface‚Äôi √ßaƒüƒ±ran sƒ±nƒ±f tarafƒ±ndan deƒüi≈ütirilemezler. Interface‚Äôler de Abstract class‚Äôlar gibi polymorphism √∂zelliƒüi ile implement edildikleri sƒ±nƒ±fƒ±n referansƒ±nƒ± tutabilirler.

Ek olarak, genellikle interface isimlerinin ba≈üƒ±na kodun okunurluƒüunun artmasƒ± i√ßin I harfi yazƒ±lƒ±r. 

Interface hakkƒ±nda bilgi edindikten sonra √∂rnekler yapmaya ba≈üladƒ±m. A≈üaƒüƒ±daki √∂rnekte bir firmanƒ±n √ßalƒ±≈üanlarƒ±nƒ±n durumlarƒ±na g√∂re interface implement ettiƒüi √ßalƒ±≈üan sƒ±nƒ±flarƒ± olu≈üturdum. Kafein Yazƒ±lƒ±m gibi firmalardan outsource olarak √ßalƒ±≈üan ki≈üiler i√ßin OutsourceWorker, firmanƒ±n kendi √ßalƒ±≈üanlarƒ± i√ßin Worker sƒ±nƒ±flarƒ± olu≈üturdum. Sonrasƒ±nda bu sƒ±nƒ±flar i√ßin firma b√ºnyesinde √ßalƒ±≈üƒ±yor ise IWorkable interface‚Äôini, yemek masraflarƒ± firma tarafƒ±ndan kar≈üƒ±lanƒ±yorsa IEatable interface‚Äôini, maa≈üƒ± firma tarafƒ±ndan √∂deniyorsa IPayable interface‚Äôini, ikramiye/√∂d√ºllendirme var ise IRewardable interface‚Äôini implement ettim.
```java
public interface IWorkable {
    void work();
    void workingHours();
}
```
```java
public interface IEatable {
    void eat();
}
```
```java
public interface IPayable {
    void pay();
}
```
```java
public interface IRewardable {
    void reward();
}
```
```java
public class Worker implements IWorkable, IPayable, IEatable, IRewardable{
    @Override
    public void work() {
        //works for us
    }
    @Override
    public void workingHours() {
        System.out.println("Works 9am to 6pm");
    }
    @Override
    public void pay() {
        //we pay their salary
    }
    @Override
    public void eat() {
        //we pay for their food expenses
    }
    @Override
    public void reward() {
        //we give them rewards
    }
}
```
```java
public class OutsourceWorker implements IWorkable, IEatable {
    @Override
    public void work() {
        //works for us by outsourcing
    }
    @Override
    public void workingHours() {
        System.out.println("Works 10am to 5pm");
    }
    @Override
    public void eat() {
        //we pay for their food expenses
    }
}
```
        
Java'da Static deyimi, sƒ±nƒ±f deƒüi≈ükenlerini veya sƒ±nƒ±f metotlarƒ±nƒ± tanƒ±mlarken kullanƒ±lƒ±r. Eƒüer bir sƒ±nƒ±fa ait deƒüi≈ükenlerin ba≈üƒ±na static yazƒ±lƒ±rsa, o deƒüi≈ükenler artƒ±k sƒ±nƒ±f deƒüi≈ükeni olurlar. Sƒ±nƒ±f deƒüi≈ükeni olarak tanƒ±mlanan deƒüi≈ükenler, her nesne olu≈üturduƒüumuzda ayrƒ± ayrƒ± olu≈ümazlar. Sƒ±nƒ±fa ait ne kadar nesne olursa olsun, sƒ±nƒ±f deƒüi≈ükenleri bir tanedir. Sƒ±nƒ±fa ait herhangi bir nesne √ºzerinden bu deƒüi≈ükene ula≈üƒ±labilir. Yani, static deƒüerler sƒ±nƒ±fa ait iken static olmayan deƒüerler o sƒ±nƒ±fƒ±n nesnelerine aittir denebilir. Static deƒüerlere sƒ±nƒ±f isminin yanƒ±na nokta koyularak eri≈üilirken (√∂r: `Class.staticVar()`), static olmayan deƒüerlere ait olduklarƒ± nesne isminin yanƒ±na nokta koyularak eri≈üilir (√∂r: `object.nonstaticVar()`). Sƒ±nƒ±f deƒüi≈ükenlerinin bir diƒüer √∂zelliƒüi ise, ilgili sƒ±nƒ±fa ait hi√ß nesne olu≈üturulmasa bile bellekte yer kaplarlar.

√ñte yandan, eƒüer sƒ±nƒ±fa ait metotlardan bir ya da birden fazlasƒ±nƒ±n √∂n√ºne static deyimi yazƒ±lƒ±rsa, o metotlar sƒ±nƒ±f metodu olurlar. Sƒ±nƒ±f metotlarƒ±nƒ±n en √∂nemli √∂zelliƒüi, ilgili sƒ±nƒ±fa ait nesne olu≈üturulmadan √ßaƒüƒ±rƒ±labilir olmalarƒ±dƒ±r. Bu durumda, nesne var olmadan √ßaƒürƒ±labilecek olan sƒ±nƒ±f metotlarƒ±nƒ±n, nesne var olmadan bellekte var olamayan nesne deƒüi≈ükenlerine eri≈ümesi olanaklƒ± deƒüildir. Kƒ±saca, static deƒüerler sadece static deƒüerleri √ßaƒüƒ±rabilir ve kullanabilir. Static olmayan deƒüerler de sadece static olmayan deƒüerleri √ßaƒüƒ±rƒ±p kullanabilir. Yani, new anahtar kelimesi ile olu≈üturulan bir nesne, ait olduƒüu sƒ±nƒ±fƒ±n static metotlarƒ±na eri≈üemez. Benzer ≈üekilde, static olmayan metotlara da bir nesne olu≈üturmadan eri≈üemeyiz.

Java‚Äôda outer class‚Äôlar static olamazken, inner class‚Äôlar (bir sƒ±nƒ±fƒ±n i√ßinde bulunan sƒ±nƒ±flar) static olabilirler. ƒ∞√ß i√ße tanƒ±mlanan sƒ±nƒ±flarƒ± tabir ederken, diƒüerini kapsayan sƒ±nƒ±fa dƒ±≈ütaki sƒ±nƒ±f (outer class), i√ßeride bulunan sƒ±nƒ±fa ise i√ßteki sƒ±nƒ±f (inner class) denir. ƒ∞√ß i√ße sƒ±nƒ±flarda, i√ßteki sƒ±nƒ±fƒ± kullanabilmemiz i√ßin dƒ±≈ütaki sƒ±nƒ±fƒ±n bir √∂rneƒüinin alƒ±nmasƒ± gerekir.

ƒ∞√ßteki sƒ±nƒ±f, dƒ±≈ütaki sƒ±nƒ±fƒ±n b√ºt√ºn alanlarƒ±na ve metotlarƒ±na eri≈üebilir. Dƒ±≈ütaki sƒ±nƒ±f tek olmasƒ±na raƒümen, i√ßteki sƒ±nƒ±fƒ±n birden fazla √∂rneƒüi alƒ±nabilir; bu gibi durumlarda i√ßteki sƒ±nƒ±ftan olu≈üturulan nesnelerin hepsi aynƒ± dƒ±≈ütaki sƒ±nƒ±fa eri≈üir

## üìî Java 10. G√ºn
### Java‚Äôda Collections (Koleksiyonlar) ‚Äì ArrayList ve Hashmap ve Java‚Äôda Exception Handling
Java Collections (Koleksiyonlar), nesne grubunu depolamak veya i≈ülem yapma gibi i≈ülemleri saƒülayan bir t√ºrd√ºr. Genel itibariyle Set, List ve Map olmak √ºzere 3 temel t√ºrden olu≈ümaktadƒ±r. Bunlara Collection Framework denmektedir. Java Collections veri depolamak, veri silmek, veri ekleme ve depolanan verileri i√ßerisinde veri aramak gibi i≈ülemler i√ßin kullanƒ±lƒ±rlar.

List koleksiyon t√ºr√ºnden t√ºremi≈ü bir alt sƒ±nƒ±f olan ArrayList, liste halindeki verileri dinamik diziler(array) kullanarak saklar. Default boyutu 10‚Äôdur. Bu dizilere yeni eleman eklendik√ße eƒüer boyutu yetmiyorsa, √ßalƒ±≈üma zamanƒ±nda, arka tarafta var olan dizinin boyutunun 2 katƒ± olan yeni dizi tanƒ±mlanƒ±r. Eski dizideki elemanlar index deƒüerleri korunarak yeni diziye aktarƒ±lƒ±rlar. ArrayList sƒ±nƒ±fƒ±nƒ± kullanabilmek i√ßin java.util.ArrayList paketini import etmemiz gerekir.

ArrayList sƒ±nƒ±fƒ±, C++‚Äôtaki vector‚Äôlere kar≈üƒ±lƒ±k geliyor denebilir. Ancak vector‚Äôlerden farklƒ± olarak type-safe olmadan (non-generic) da yazƒ±labilir. Yani, array‚Äôin hangi tipte veri alacaƒüƒ± belirtilmezse array her t√ºrden veriyi saklayabilir. Ayrƒ±ca, ArrayListler kendi olu≈üturduƒüumuz sƒ±nƒ±fƒ±n t√ºr√ºnde de deƒüerler tutabilirler.

ArrayList sƒ±nƒ±fƒ± `get()`, `remove()`, `indexOf()` gibi fonksiyonlar barƒ±ndƒ±rƒ±r. Bu fonksiyonlarƒ±n bazƒ±larƒ±nƒ±n isimleri C++‚Äôtaki vector yapƒ±sƒ±nƒ±n fonksiyonlarƒ±ndan farklƒ± olsa da aynƒ± i≈ülemleri ger√ßekle≈ütiriyorlar. 

Ek olarak, non-generic ArrayList‚Äôlerde for-each d√∂ng√ºs√º yapƒ±lƒ±rken iterator‚Äôƒ±n veri tipine Object yazƒ±lƒ±r.
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList list1 = new ArrayList();
        list1.add(5);
        list1.add("ƒ∞stanbul");
        list1.add('a');
        list1.add(3.2);
        list1.remove(2);

        for(Object obj : list1){
            System.out.println(obj);
        }

        System.out.println("---------");

        ArrayList<Integer> list2 = new ArrayList<Integer>();
        list2.add(5);
        list2.add(6);
        list2.add(7);
        list2.add(8);
        list2.remove(2);

        for(int n : list2){
            System.out.println(n);
        }

        System.out.println(list2.indexOf(8));
    }
}
```
       
HashMap sƒ±nƒ±fƒ±, verileri key ‚Äì value (anahtar ‚Äì deƒüer) √ßiftleri olarak saklar. Key ile value‚Äônun aynƒ± tipte olmasƒ±na gerek yoktur. ƒ∞kisi de herhangi bir t√ºrde olabilir. Key deƒüerleri bir index gibi √ßalƒ±≈üƒ±r diyebiliriz. Bir HashMap deƒüerine(value) ula≈ümak i√ßin anahtarƒ±nƒ± bilmemiz gerekir. HashMap, yinelenen deƒüerlere izin verir, ancak yinelenen anahtarlara izin vermez. HashMap sƒ±nƒ±fƒ±nƒ± kullanabilmek i√ßin java.util.HashMap paketini import etmemiz gerekir.

HashMap sƒ±nƒ±fƒ± keySet(), get(), containsKey(), containsValue() gibi metotlar i√ßerir. Java‚Äôdaki HashMap sƒ±nƒ±fƒ± C++‚Äôtaki unordered_map yapƒ±sƒ±na kar≈üƒ±lƒ±k geliyor denebilir. ArrayList sƒ±nƒ±fƒ±ndaki gibi bu fonksiyonlarƒ±n bazƒ±larƒ±nƒ±n isimleri C++‚Äôtaki unordered_map yapƒ±sƒ±nƒ±n fonksiyonlarƒ±ndan farklƒ± olsa da aynƒ± i≈ülemleri ger√ßekle≈ütiriyorlar.
```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        HashMap<String, Integer> hashTable = new HashMap<>();
        hashTable.put("ƒ∞stanbul", 34);
        hashTable.put("Trabzon", 61);
        hashTable.put("Sinop", 57);

        for(String n : hashTable.keySet()){
            System.out.println(hashTable.get(n));
        }
        System.out.println("------");
        System.out.println(hashTable.get("Trabzon"));

        hashTable.remove("Trabzon");
        System.out.println(hashTable);
    }
}
```
       
Java‚Äônƒ±n Exception Handling (hata y√∂netimi) mekanizmasƒ± ≈üu ≈üekilde i≈üler: Programƒ±n √ßalƒ±≈ümasƒ± sƒ±rasƒ±nda istisnai bir durum olu≈üursa bu durumla ilgili bir nesne olu≈üturulur ve throws deyimiyle fƒ±rlatƒ±lƒ±r. B√∂yle bir durumda, programƒ±n olaƒüan akƒ±≈üƒ± durdurulur ve bu hatanƒ±n yakalanmasƒ± beklenir. Hatanƒ±n yakalanabilmesi i√ßin, hataya sebep olan kodun try-catch bloƒüu i√ßine yazƒ±lmasƒ± gerekir. Bu durumda Java √ßalƒ±≈üma ortamƒ±, meydana gelen hatayƒ± yakalayabilecek bir catch bloƒüu arar, eƒüer bulursa bu catch bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±r. Son olarak, eƒüer bir finally bloƒüu yazƒ±lmƒ±≈üsa bu blok √ßalƒ±≈ütƒ±rƒ±lƒ±r ve program normal akƒ±≈üƒ±na devam eder. try bloƒüu i√ßindeki kod bloƒüu hata alsƒ±n ya da almasƒ±n "finally" bloƒüu her ko≈üulda √ßalƒ±≈ütƒ±rƒ±lƒ±r ve opsiyoneldir.

Hata durumlarƒ±nƒ± y√∂netmek i√ßin 2 y√∂ntem vardƒ±r. Try-catch bloklarƒ± ile hatayƒ± alƒ±nacaƒüƒ± tahmin edilen yerde kontrol altƒ±na alabiliriz veya hatayƒ± throws anahtar kelimesi ile √ßaƒürƒ±ldƒ±ƒüƒ± bir √ºst noktaya fƒ±rlatarak, √ß√∂z√ºm√ºn orada yapƒ±lmasƒ±nƒ± zorunlu hale getiririz. throws ifadesine sahip bir metodun, ya √ßaƒürƒ±ldƒ±ƒüƒ± zaman try-catch bloƒüu i√ßerisinde √ßaƒüƒ±rƒ±lmalƒ±dƒ±r ya da √ßaƒüƒ±ran metoda throws anahtar kelimesi eklenmelidir. Ayrƒ±ca Java‚Äôda Exception ata sƒ±nƒ±fƒ±nƒ± t√ºreterek kendi exception‚Äôlarƒ±mƒ±zƒ± yazabiliyoruz.

```java
public class BalanceInsufficientException extends Exception{
    String message;

    public BalanceInsufficientException(String message){
        this.message = message;
    }

    @Override
    public String getMessage() {
        return this.message;
    }
}
```
```java
public class AccountManager {
    private double balance;

    public void deposit(double amount){
        balance = getBalance() + amount;
    }

    public void withdraw(double amount) throws BalanceInsufficientException{
        if(amount < getBalance()){
           balance = getBalance() - amount;
        }
        else{
            throw new BalanceInsufficientException("Insufficient Balance!");
        }
    }

    public double getBalance() {
        return balance;
    }
}
```

## üìî Java 11. G√ºn
### Java‚Äôda Generics ve Threading

Generics (Jenerikler), kelime anlamƒ± itibariyle parametrelendirilmi≈ü t√ºr anlamƒ±na gelir. Jenerikler sayesinde, sƒ±nƒ±f, aray√ºz veya metot yazarken tek bir t√ºre baƒülƒ± kalmayƒ±p √ºzerinde i≈ülem yapacaƒüƒ±nƒ±z t√ºr√º parametre olarak alabilirsiniz. Bu sayede, farklƒ± t√ºrler √ºzerinde √ßalƒ±≈üan tek bir sƒ±nƒ±f yazmak m√ºmk√ºnd√ºr. Bu ≈üekilde yazƒ±lan sƒ±nƒ±flara Generic Class, metotlara Generic Method denir.

Jenerikler, Class ve Interface‚Äôlerin tanƒ±mƒ±nda kullanƒ±lƒ±rken class/interface‚Äôin isminden sonra < ve > i≈üaretleri yazƒ±lƒ±r ve bu i≈üaretlerin ortasƒ±na t√ºr i√ßin bir deƒüi≈üken ismi yazƒ±lƒ±r. Genelde bunun i√ßin T harfi kullanƒ±lƒ±r (√∂r: <T>). Ardƒ±ndan yalnƒ±zca belirttiƒüimiz t√ºr√ºn ve alt sƒ±nƒ±flarƒ±nƒ±n kullanƒ±labilmesi isteniyorsa veya t√ºr√ºn bir interface‚Äôi implement etmesi isteniyorsa extends anahtar s√∂zc√ºƒü√º kullanƒ±lƒ±r. √ñte yandan yalnƒ±zca belirttiƒüimiz t√ºr√ºn ve √ºst sƒ±nƒ±flarƒ±nƒ±n kullanƒ±labilmesi isteniyorsa i√ßin super anahtar kelimesi kullanƒ±lƒ±r.

Generic metotlar tanƒ±mlanƒ±rken ise metotun Acces Modifier‚Äôƒ± (public vb.) yazƒ±ldƒ±ktan sonra, metodun d√∂n√º≈ü t√ºp√º ve isminden √∂nce aynƒ± yazƒ±m(<T>) kullanƒ±lƒ±r.

Jenerikler JDK 5 ile dile eklenmi≈ütir. Buna raƒümen, Java‚Äônƒ±n en temel √∂zelliklerinden biridir ve dili temelden etkilemi≈ütir. Jenerikler, bir yandan farklƒ± t√ºrler i√ßin tek bir kod yazmamƒ±zƒ± saƒülarken, diƒüer yandan t√ºr g√ºvenliƒüini saƒülar.
```java
public interface IDatabaseManager<T extends Student> {
    void add(T item);
    void remove(T item);
    void update(T item);
    T get(int id);
}
```
```java
import java.util.ArrayList;

public class StudentDatabaseManager implements IDatabaseManager<Student>{
    @Override
    public void add(Student item) {
        //Database codes
        System.out.println("Added to the database.");
    }
    @Override
    public void remove(Student item) {
        //Database codes
        System.out.println("Removed from the database.");
    }
    @Override
    public void update(Student item) {
        //Database codes
        System.out.println("Added to the database.");
    }
    @Override
    public Student get(int id) {
        //Database codes
        ArrayList<String> testCourses = new ArrayList<String>();
        testCourses.add("Calculus");
        return new Student("Example Student", id, testCourses);
    }
}
```
  ```java
import java.util.ArrayList;

public class Student {
    private String name;
    private int id;
    ArrayList<String> courses;

    public Student(String name, int id, ArrayList<String> courses){
        this.name = name;
        this.id = id;
        this.courses = courses;
    }

    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }
}
```
```java
public class Validator {
    public static <T> void validate(T item){
        System.out.println("Data is valid.");
    }
}
```
        
Her bir i≈ülemin altƒ±nda √ßalƒ±≈üan i≈ülem par√ßacƒ±klarƒ±na thread adƒ± verilir. Thread‚Äôler bir ana i≈ülemin i√ßerisinde √ßalƒ±≈üan ve processlere (i≈ülem) g√∂re daha az kaynak t√ºketerek asenkron olarak √ßalƒ±≈üan yapƒ±lardƒ±r. Multithreading, i≈ülemcinin daha efektif bir bi√ßimde kullanƒ±labilmesi i√ßin bir programƒ±n farklƒ± i≈ülemlerinin ayrƒ± ayrƒ± i≈ülem par√ßacƒ±klarƒ±nda yapƒ±lmasƒ±dƒ±r. Normalde i≈ülemler sƒ±rasƒ±yla art arda ger√ßekle≈ütirilirken bu yapƒ± sayesinde i≈ülemler birbirlerini beklemeden kendi i≈ülemini yapar. Java‚Äôda kodumuzun aynƒ± anda birden fazla i≈ülem yapmasƒ±nƒ± istediƒüimizde zaman Thread‚Äôleri kullanmamƒ±z gerekmektedir.

Java‚Äôda thread‚Äôleri kullanmanƒ±n iki yolu vardƒ±r: 
  
‚Ä¢	Thread sƒ±nƒ±fƒ±ndan kalƒ±tƒ±m alan bir alt sƒ±nƒ±f yaratƒ±p, onun run() fonksiyonu override edilir, ardƒ±ndan start() metodu ile bu sƒ±nƒ±f √ßaƒürƒ±lƒ±r.
  
‚Ä¢	Runnable interface‚Äôinden kalƒ±tƒ±m alan bir alt sƒ±nƒ±f yaratƒ±lƒ±r ve run() fonksiyonunu override edilir ardƒ±ndan start() metodu ile bu sƒ±nƒ±f √ßaƒürƒ±lƒ±r.

Java‚Äôda bir i≈ü par√ßacƒ±ƒüƒ±nƒ± belli bir s√ºre bekletmek istersek, Thread sƒ±nƒ±fƒ±na ait sleep() fonksiyonunu kullanabiliriz. Ancak bu y√∂ntem senkronizasyonu saƒülarken thread yapƒ±sƒ±nƒ±n saƒüladƒ±ƒüƒ± avantajƒ± ortadan kaldƒ±rƒ±r. sleep() fonksiyonu milisaniye cinsinden bir deƒüer alƒ±r. Yani 1000 deƒüeri girildiƒüinde 1 saniyeye kar≈üƒ±lƒ±k gelmektedir. sleep() fonksiyonu hata fƒ±rlatabilen bir fonksiyon olduƒüundan try-catch bloƒüu i√ßinde kontrol edilmelidir

Thread sƒ±nƒ±fƒ±nƒ± extend ederek kullanma y√∂ntemi genellikle tercih edilen bir y√∂ntem deƒüildir. √á√ºnk√º yazƒ±lƒ±mƒ±mƒ±zdaki i≈ü akƒ±≈üƒ± i√ßerisinde sƒ±nƒ±fƒ±mƒ±zƒ±n katƒ±lƒ±m geli≈üimini engellemi≈ü oluyoruz. √á√ºnk√º Java‚Äôda bir sƒ±nƒ±f birden fazla sƒ±nƒ±ftan miras alamaz. Bu sebeple Runnable‚Äôƒ± implement ederek kullanmayƒ± tercih etmek daha doƒüru olacaktƒ±r denebilir.

√ñƒürendiklerimden sonra √∂rnekler yapmaya ba≈üladƒ±m. A≈üaƒüƒ±daki √∂rnekte 5‚Äôe kadar senkronize olarak sayan 2 kronometre olu≈üturdum. sleep() fonksiyonunu kullanarak ger√ßek bir kronometre gibi saniye bazlƒ± olarak saymasƒ±nƒ± saƒüladƒ±m.
```java
public class ChronometerThread implements Runnable{
    private Thread thread;
    private String threadName;

    ChronometerThread(String threadName){
        this.threadName = threadName;
        System.out.println("Creating a thread: " + threadName);
    }

    @Override
    public void run() {
        try{
            for(int i = 0; i <= 5; i++){
                System.out.println(threadName + ": " + i);
                Thread.sleep(1000);
            }
        }catch(InterruptedException exception){
            System.out.println("Error!");
        }

        System.out.println("Thread " + threadName + " is over.");
    }

    public void start(){
        System.out.println("Creating a thread object");
        if(thread == null){
            thread = new Thread(this, threadName);
            thread.start();
        }
    }
}
```
                                 

## üìî Java 12. G√ºn
### MySQL kurulumu, temel SQL sorgularƒ± ve Java‚Äôda JDBC ile database (veri tabanƒ±) baƒülantƒ±sƒ±
SQL, ili≈ükisel bir veri tabanƒ±ndaki verilerin alƒ±nmasƒ± ve y√∂netimi i√ßin tasarlanmƒ±≈ü bir veri tabanƒ± dilidir. SQL, Yapƒ±landƒ±rƒ±lmƒ±≈ü Sorgu Dili anlamƒ±na gelir. Komutlar genelde b√ºy√ºk harfle yazƒ±lsa da SQL dili case sensitive bir dil deƒüildir yani b√ºy√ºk harf - k√º√ß√ºk harf duyarlƒ±lƒ±ƒüƒ± yoktur. T√ºm SQL komutlarƒ± SELECT, WHERE, INSERT, UPDATE, DELETE, ALTER, DROP, CREATE gibi anahtar kelimelerin herhangi biriyle ba≈ülar ve noktalƒ± virg√ºl ile (;) biter.

MySQL‚Äôin kurulumla beraber gelen, √ºlke ve ≈üehirleri i√ßeren world verisi ile komutlarƒ± √∂ƒürendik√ße √∂rnek uygulamalarƒ±nƒ± yaptƒ±m.

**SELECT** en √ßok kullanƒ±lan SQL komutudur ve veri tabanƒ±ndan belirtilen s√ºtunlardaki verileri √ßekmemizi saƒülar. SELECT komutunu √ßoƒüunlukla diƒüer SQL komutlarƒ±yla birlikte kullanƒ±rƒ±z. Eƒüer tablodaki t√ºm s√ºtunlardaki verileri √ßekmek istersek Java paketlerinde olduƒüu gibi * karakterini kullanƒ±rƒ±z.

```sql
select * from country;
```
```sql
select Name,Continent,Region from country;
```

**WHERE** komutu, yalnƒ±zca belirtilen bir ko≈üulu yerine getiren kayƒ±tlarƒ± ayƒ±klamak i√ßin kullanƒ±lƒ±r.
```sql
SELECT * from country WHERE Continent = 'Europe' AND Population > 50000000;
```

**INSERT INTO** komutu, tabloya yeni kayƒ±tlar eklemek i√ßin kullanƒ±lƒ±r.
```sql
INSERT INTO city (Name, CountryCode, District, Population) values('D√ºzce','TUR','D√ºzce',1000);
```
  
**UPDATE** komutu, bir tablodaki var olan kayƒ±tlarƒ± deƒüi≈ütirmek, g√ºncellemek amacƒ±yla kullanƒ±lƒ±r. Ancak ≈üart belirtilmediƒüinde g√ºncellemeden tablodaki t√ºm kayƒ±tlar etkilenecektir.
```sql
UPDATE city set Population = 500000 WHERE Name = 'D√ºzce';
```
  
**DELETE** komutu, veri tabanƒ±ndan kayƒ±t ya da kayƒ±tlarƒ± silmek i√ßin kullanƒ±lƒ±r. Ancak ≈üart belirtilmediƒüinde tablodaki t√ºm kayƒ±tlar silinir.
```sql
delete from city where id = 4084;
```
         
JDBC, Java diliyle veri tabanlarƒ±na baƒülanƒ±p sorgu (query) √ßalƒ±≈ütƒ±rmak, veri tabanƒ± ile etkile≈üimli uygulamalar geli≈ütirmek i√ßin ortaya √ßƒ±kmƒ±≈ü bir k√ºt√ºphanedir. JDK i√ßinde varsayƒ±lan olarak hazƒ±r kullanƒ±labilir ≈üekilde gelmektedir. JDBC API her veri tabanƒ± y√∂netim sistemi i√ßin yazƒ±lmƒ±≈ü olan s√ºr√ºc√º k√ºt√ºphanelerini kullanarak veri tabanƒ± i≈ülemlerini yapabilmeyi saƒülar. Java ve veri tabanƒ± arasƒ±nda k√∂pr√º g√∂revi g√∂r√ºr.

JDBC, Java ile veri tabanƒ± ile etkile≈üimde olan kodlarƒ± yazdƒ±ƒüƒ±mƒ±zda, s√ºr√ºc√º k√ºt√ºphane √∂rneƒüin MySQL‚Äôden Oracle veri tabanƒ± sistemine ge√ßse bile hi√ßbir deƒüi≈üiklik gerektirmeden kullanƒ±mƒ±nƒ± saƒülar. B√∂ylece, Java ile veri tabanƒ±yla i≈ülemler yapabilmek i√ßin yazdƒ±ƒüƒ±nƒ±z kodlarƒ± deƒüi≈ütirmeden istediƒüimiz veri tabanƒ± sistemiyle √ßalƒ±≈üabiliriz. B√∂ylece Java kodlarƒ±nƒ±n yeniden kullanƒ±labilirliƒüini artmaktadƒ±r. JDBC API ile veri tabanƒ± baƒülantƒ±sƒ± olu≈üturup, tablolar √ºzerinde sorgu √ßalƒ±≈ütƒ±rabiliyoruz. Sorgulama, veri g√ºncelleme, silme veya yeni kayƒ±t ekleme i≈ülemlerini yapabiliyoruz.

JDBC API veritabanƒ± i≈ülemleri i√ßin gerekli olan abstractionƒ± saƒülar, daha sonra kendisine verilen driver ile sorgularƒ± ilgili veritabanƒ±na iletir, sorgunun √ßalƒ±≈ütƒ±rƒ±lmasƒ± sonucunda √ºretilen √ßƒ±ktƒ±yƒ± da java uygulamasƒ±na geri iletir. Burada √∂nemli olan hangi veritabanƒ±na baƒülanƒ±lacaksa ona uygun driver kullanƒ±lmasƒ±dƒ±r. JDBC ile veri tabanƒ± baƒülantƒ±sƒ± kurabilmek i√ßin √∂ncelikle Intellij IDEA √ºzerinden MySQL ile birlikte gelen mysql-connector-java k√ºt√ºphanesini bu konu i√ßin olu≈üturduƒüum projeme ekledim.
		
DriverManager sƒ±nƒ±fƒ±nda bulunan static `getConnection()` metodu, kendisine verdiƒüimiz parametreleri kullanarak uygulamamƒ±z ve veri tabanƒ± arasƒ±nda bir baƒülantƒ± kurulmasƒ±nƒ± saƒülar. Bu metot √º√ß tane String parametre alƒ±r. ƒ∞lki veri tabanƒ±nƒ±n url‚Äôsi, ikincisi kullanƒ±cƒ± adƒ± ve √º√ß√ºnc√ºs√º ise kullanƒ±cƒ± ≈üifresidir. `getConnection()` metodu geri d√∂n√º≈ü olarak Connection aray√ºz√ºn√º uygulayan bir sƒ±nƒ±f d√∂nd√ºr√ºr.

Baƒülantƒ± kurulduktan sonra JDBC API ile artƒ±k sorgu √ßalƒ±≈ütƒ±rabiliriz. Veri tabanƒ±na SQL ifadesi g√∂ndermek i√ßin Statement aray√ºz√ºnden t√ºretilen objeler yaratmamƒ±z gerekir. `getConnection()` metodu vasƒ±tasƒ±yla olu≈üturduƒüumuz Connection t√ºr√ºndeki nesne, veri tabanƒ± sunucusuyla uygulamamƒ±z arasƒ±ndaki baƒülantƒ± nesnesidir. Bu nesne √ºzerinden `createStatement()` fonksiyonu ile sorgu hazƒ±rlayabileceƒüimiz Statement tipinde bir nesne alƒ±rƒ±z. Statik veriler kullanƒ±rken SQL sorgularƒ±mƒ±zƒ± bu nesne tipi √ºzerinden yaparƒ±z. Bu nesnenin `executeQuery()` metodu SELECT sorgularƒ±nƒ± √ßalƒ±≈ütƒ±rmak i√ßin kullanƒ±lƒ±r, parametre olarak String tipinde select sorgusunu alƒ±r ve elde edilen sonu√ßlar ResultSet objesi olarak geri d√∂ner. Tabloda veya veri tabanƒ±nda yapƒ±sal deƒüi≈üikliƒüe yol a√ßan INSERT, UPDATE, DELETE, CREATE, ALTER, DROP gibi komutlar ise bu nesnenin `executeUpdate()` metodu ile kullanƒ±labilir. Bu metod INSERT, UPDATE ve DELETE komutlarƒ± ile √ßalƒ±≈ütƒ±rƒ±ldƒ±ƒüƒ± zaman bu komuttan etkilenen kayƒ±t sayƒ±nƒ± d√∂nd√ºr√ºr. CREATE, ALTER, DROP komutlarƒ± ile √ßalƒ±≈ütƒ±rƒ±ldƒ±ƒüƒ± zaman ise sƒ±fƒ±r deƒüeri d√∂nd√ºr√ºr. 

Veri √ßekme i≈ülemi sonrasƒ±nda veri listelemek i√ßin kullanƒ±lan ResultSet sƒ±nƒ±fƒ± veriler √ºzerinde dola≈ümak i√ßin `next()`, `first()`, `last()`, `previous()`, `absolute()` gibi metotlara sahiptir. `next()` fonksiyonu: bu fonksiyon √ßaƒürƒ±ldƒ±ƒüƒ±nda bir sonraki satƒ±ra ilerler. B√∂ylece o satƒ±r √ºzerinde okuma yapabilmeyi saƒülar. Okunacak kayƒ±t kalmadƒ±ƒüƒ±nda ‚Äúfalse‚Äù d√∂ner. `first()` fonksiyonu √ßaƒürƒ±ldƒ±ƒüƒ±nda sorgu sonucu k√ºmesindeki ilk elemana eri≈üim saƒülar. `last()` fonksiyonu √ßaƒürƒ±ldƒ±ƒüƒ±nda sorgu sonucu k√ºmesindeki son elemana eri≈üim saƒülar. `absolute()` fonksiyonu ile sorgu sonu√ß k√ºmesindeki direkt olarak istenilen eleman i≈üaret edilir. Veritabanƒ± s√ºtunlarƒ±nda yer alan verileri almak i√ßin ise `getString()`, `getInt()` gibi metotlar kullanƒ±lƒ±r.

Ayrƒ±ca SQLException sƒ±nƒ±fƒ±, bir veri tabanƒ± baƒülantƒ±sƒ± ve uygulamalarƒ±nda meydana gelen hatalarƒ± y√∂netir. JDBC kullanƒ±rken kullanƒ±lan metotlar SQLException exception‚Äôlarƒ± √ºrettiƒüi i√ßin bu metotlar try-catch bloklarƒ± i√ßinde kullanƒ±lmalƒ±dƒ±r. Ayrƒ±ca son olarak kullandƒ±ƒüƒ±mƒ±z Connection, Statement, ResultSet vb. t√ºrlerindeki nesnelerin baƒülantƒ±sƒ±nƒ± `close()` metodu ile kapatmalƒ±yƒ±z.
  
```java
import java.sql.*;

public class Main {
    public static void main(String[] args) throws SQLException{
        Connection dbConnection = null;
        Statement statement = null;
        ResultSet resultSet;
        DbHelper helper = new DbHelper();
        try{
            dbConnection = helper.getConnection();
            statement = dbConnection.createStatement();
            resultSet = statement.executeQuery("SELECT Code, Name, Continent, Region from country");
            int count = 0;
            while(resultSet.next()){
                System.out.println(resultSet.getString("Name") + " " + resultSet.getString("Code"));
                count++;
            }
            System.out.println("-- " + count + " countries printed --");
        }
        catch(SQLException exception){
            helper.showErrorMessage(exception);
        }
        finally {
            dbConnection.close();
        }
    }
}
```
  
## üìî Java 13. G√ºn
### Java‚Äôda JDBC ile veri tabanƒ± i≈ülemleri (SELECT, INSERT, UPDATE, DELETE) ve verileri nesnelere aktarma
Veri tabanƒ± baƒülantƒ±sƒ± kurduƒüum main metodunun bazƒ± kƒ±sƒ±mlarƒ±nƒ± DbHelper adlƒ± ba≈üka bir class‚Äôa ta≈üƒ±dƒ±m. 
```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DbHelper {
    private String userName = "root";
    private String password = "12345";
    private String dbUrl = "jdbc:mysql://localhost:3306/world";

    public Connection getConnection() throws SQLException {
        return DriverManager.getConnection(dbUrl, userName, password);
    }

    public void showErrorMessage(SQLException exception){
        System.out.println("Error: " + exception.getMessage());
        System.out.println("Error Code: " + exception.getErrorCode());
    }
}
```
Sonrasƒ±nda SELECT sorgusu ile Java √ºzerinden world database‚Äôindeki t√ºm √ºlkelerin isimlerini, kodlarƒ±nƒ±, kƒ±talarƒ±nƒ± ve b√∂lgelerinin verisini √ßektim. Ardƒ±ndan bu √ºlkelerin isim ve kodlarƒ±nƒ± ekrana bastƒ±rdƒ±m.
```java
import java.sql.*;

public class Main {
    public static void main(String[] args) throws SQLException{
        Connection dbConnection = null;
        Statement statement = null;
        ResultSet resultSet;
        DbHelper helper = new DbHelper();
        try{
            dbConnection = helper.getConnection();
            statement = dbConnection.createStatement();
            resultSet = statement.executeQuery("SELECT Code, Name, Continent, Region from country");
            int count = 0;
            while(resultSet.next()){
                System.out.println(resultSet.getString("Name") + " " + resultSet.getString("Code"));
                count++;
            }
            System.out.println("-- " + count + " countries printed --");
        }
        catch(SQLException exception){
            helper.showErrorMessage(exception);
        }
        finally {
            dbConnection.close();
        }
    }
}
```
Ardƒ±ndan verileri nesnelere aktarmak i√ßin bir Country sƒ±nƒ±fƒ± olu≈üturdum. Main metodunda deƒüi≈üiklikler yaparak veri tabanƒ±ndaki √ºlkelerin isim, kod, kƒ±ta ve b√∂lge verileriyle bir ArrayList‚Äôe Country nesnesi olarak ekledim.
```java
public class Country {
    private String code;
    private String name;
    private String continent;
    private String region;

    public Country(String code, String name, String continent, String region){
        this.code = code;
        this.name = name;
        this.continent = continent;
        this.region = region;
    }
}
```
```java
import java.sql.*;
import java.util.ArrayList;
  
public class Main {
    public static void main(String[] args) throws SQLException{
        DbHelper helper = new DbHelper();
        Connection dbConnection = null;
        Statement statement = null;
        ResultSet resultSet;
        ArrayList<Country> countries = new ArrayList<Country>();
        try{
            dbConnection = helper.getConnection();
            statement = dbConnection.createStatement();
            resultSet = statement.executeQuery("SELECT Code, Name, Continent, Region from country");
            while(resultSet.next()){
                countries.add(new Country(resultSet.getString("Code"), resultSet.getString("Name"), resultSet.getString("Continent"), resultSet.getString("Region")));
            }
            System.out.println(countries.size() + " countries added to the ArrayList.");
        }
        catch(SQLException exception){
            helper.showErrorMessage(exception);
        }
        finally {
            dbConnection.close();
        }
    }
}
```
Ardƒ±ndan, √∂nceki kodumun try bloƒüunu deƒüi≈ütirerek D√ºzce ≈üehrini world veri tabanƒ±nƒ±n city tablosuna Java √ºzerinden insert ettim.
```java
try{
    dbConnection = helper.getConnection();
    statement = dbConnection.createStatement();
    statement.executeUpdate("INSERT INTO city(Name, CountryCode, District, Population) values('D√ºzce','TUR','D√ºzce','500000')");
    System.out.println("Added to database.");
}
```
         
PreparedStatement interface‚Äôi verilerin dinamik olarak g√∂nderilebildiƒüi parametrik SQL sorgularƒ±nda kullanƒ±lƒ±r. √ñnce sorgu bu nesnenin `prepareStatement()` metodu ile i≈ülenir. Sonrasƒ±nda `setString()`, `setInt()` gibi, SQL sorgularƒ±nda yer alan alanlara deƒüer atamaya yarayan, metotlarla parametre sƒ±rasƒ± ve veri girilir. Bu metotlar sorgu string‚Äôine yazƒ±lan ? simgelerinin yerlerine verilen sƒ±rayla deƒüer atarlar. Son olarak `executeUpdate()` ve `executeQuery()` gibi metotlar ile sorgu √ßalƒ±≈ütƒ±rƒ±lƒ±r. Statement nesnesinde her sorgu ayrƒ± ayrƒ± derlenip kullanƒ±lƒ±rken, PreparedStatement‚Äôda sorgu bir kere derlenir ve gerekli alanlara parametre ile deƒüer yollanƒ±r. Bu durum programƒ±mƒ±za hƒ±z ve d√º≈ü√ºk kaynak kullanƒ±mƒ± saƒülayabilir. 

PreparedStatement hakkƒ±nda bilgi edindikten sonra √∂ƒürendiklerimi peki≈ütirmek i√ßin √∂rnekler yaptƒ±m. 

A≈üaƒüƒ±daki √∂rnekte bir √∂nceki kodumu PreparedStatement kullanarak olu≈üturdum.
```java
import java.sql.*;
import java.util.ArrayList;
  
public class Main {
    public static void main(String[] args) throws SQLException{
        DbHelper helper = new DbHelper();
        Connection dbConnection = null;
        PreparedStatement statement = null;
        try{
            dbConnection = helper.getConnection();
            statement = dbConnection.prepareStatement(
                    "INSERT INTO city(Name, CountryCode, District, Population) VALUES(?,?,?,?)");
            statement.setString(1,"D√ºzce");
            statement.setString(2,"TUR");
            statement.setString(3,"D√ºzce");
            statement.setInt(4,800000);
            statement.executeUpdate();
            System.out.println("Added to database.");
        }
        catch(SQLException exception){
            helper.showErrorMessage(exception);
        }
        finally {
            dbConnection.close();
            statement.close();;
        }
    }
}
```
Ardƒ±ndan parametreli update i≈ülemi yaparak D√ºzce‚Äônin n√ºfus verisini 400000 olarak g√ºncelledim. Ayrƒ±ca bu sefer MySQL‚Äôden edindiƒüim id bilgisini kullanarak g√ºncelleme yaptƒ±m.
```java
import java.sql.*;
import java.util.ArrayList;
  
public class Main {
    public static void main(String[] args) throws SQLException{
        DbHelper helper = new DbHelper();
        Connection dbConnection = null;
        PreparedStatement statement = null;
        try{
            dbConnection = helper.getConnection();
            statement = dbConnection.prepareStatement("UPDATE city set Population = ? WHERE id = ?");
            statement.setInt(1,400000);
            statement.setInt(2,4087);
            statement.executeUpdate();
            System.out.println("Updated successfully.");
        }
        catch(SQLException exception){
            helper.showErrorMessage(exception);
        }
        finally {
            dbConnection.close();
            statement.close();;
        }
    }
}
```
Ardƒ±ndan DELETE sorgusu ile city tablosundan yine id‚Äôsini kullanarak D√ºzce‚Äôyi sildim.
```java
try{
    dbConnection = helper.getConnection();
    statement = dbConnection.prepareStatement("DELETE from city WHERE id = ?");
    statement.setInt(1, 4087);
    statement.executeUpdate();
    System.out.println("Deleted successfully.");
}
```
  
## üìî Java 14. G√ºn
### Java‚Äôda dosyalar ile √ßalƒ±≈ümak
